<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>纯文本阅读器</title>
    <link rel="stylesheet" href="style.css">
    <style>
        :root {
            --bg-color: #fdf6e3; --text-color: #586e75; --dialogue-color: #d9534f; --border-color: #eee8d5;
            --button-bg: #007bff; --button-text: #ffffff; --button-disabled-bg: #cccccc; --modal-bg: rgba(0,0,0,0.5);
            --highlight-bg: rgba(0, 0, 0, 0.05); --danger-color: #dc3545;
            --search-highlight-bg: #ffd900; --search-highlight-text: #000000; --search-highlight-active-bg: #ff9800;

            /* Font Style Variables */
            --font-size: 20px;
            --line-height: 1.9;
            --letter-spacing: 0px;
            --paragraph-spacing: 1em;
        }
        body.theme-dark {
            --bg-color: #212529; --text-color: #adb5bd; --dialogue-color: #e57373; --border-color: #495057;
            --button-bg: #495057; --button-text: #f8f9fa; --button-disabled-bg: #343a40; --modal-bg: rgba(0,0,0,0.7);
            --highlight-bg: rgba(255, 255, 255, 0.08); --danger-color: #e57373;
            --search-highlight-bg: #a18800; --search-highlight-text: #ffffff; --search-highlight-active-bg: #d98600;
        }
        body.theme-green { --bg-color: #cce8cf; --text-color: #3d5b3d; --dialogue-color: #b5651d; --border-color: #b7d6b9; --highlight-bg: rgba(0, 0, 0, 0.05); }
        body.theme-blue { --bg-color: #e0f0f8; --text-color: #3a506b; --dialogue-color: #c94c4c; --border-color: #c9dce8; --highlight-bg: rgba(0, 0, 0, 0.05); }
        body.theme-gray { --bg-color: #e1e1e1; --text-color: #333333; --dialogue-color: #c0392b; --border-color: #cccccc; --highlight-bg: rgba(0, 0, 0, 0.06); }

        body { font-family: 'LXGW WenKai Screen', Georgia, "Source Serif Pro", "Noto Serif SC", serif; font-display: swap; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 5px; display: flex; justify-content: center; transition: background-color 0.3s, color 0.3s; overflow: hidden; }
        #app-container { width: 100%; max-width: 1000px; height: calc(100vh - 10px); display: flex; flex-direction: column; }
        
        #bookshelf-view { width: 100%; height: 100%; padding: 10px; box-sizing: border-box; display: flex; flex-direction: column; }
        .bookshelf-header { display: flex; justify-content: space-between; align-items: center; margin: 10px 0 20px 0; border-bottom: 1px solid var(--border-color); padding-bottom: 15px; flex-shrink: 0; gap: 15px; flex-wrap: wrap; }
        .bookshelf-header h1 { margin: 0; color: var(--text-color); flex-shrink: 0; }
        #bookshelf-filter-container { margin-left: auto; display: flex; align-items: center; gap: 8px;}
        #bookshelf-filter { padding: 5px 8px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--bg-color); color: var(--text-color); font-size: 14px; }

        #bookshelf-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); gap: 30px; padding: 10px; overflow-y: auto; flex-grow: 1; cursor: grab; }
        #bookshelf-grid.is-dragging { cursor: grabbing; user-select: none; }
        .book-item { position: relative; width: 130px; height: 180px; background-color: #e0e0e0; border-radius: 3px 5px 5px 3px; box-shadow: 5px 5px 10px rgba(0,0,0,0.2); cursor: pointer; transition: transform 0.2s ease-out; display: flex; flex-direction: column; overflow: hidden; justify-self: center; }
        .book-item:hover { transform: translateY(-5px); }
        .book-item::before { content: ''; position: absolute; left: 4px; top: 0; width: 4px; height: 100%; background-image: linear-gradient(to right, rgba(0,0,0,0.2), rgba(0,0,0,0) 50%, rgba(255,255,255,0.1) 70%, rgba(0,0,0,0.1)); transform: skewY(-1deg); transform-origin: left; }
        .book-cover { flex-grow: 1; background-size: cover; background-position: center; background-color: var(--border-color); display: flex; align-items: center; justify-content: center; text-align: center; padding: 10px; }
        .book-title { background-color: rgba(0,0,0,0.6); color: white; font-size: 14px; padding: 8px 5px; width: 100%; box-sizing: border-box; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 0; }
        .book-item[data-has-cover="false"] .book-cover { font-size: 16px; font-weight: bold; color: var(--text-color); line-height: 1.4; word-break: break-all; }
        .book-item .delete-book-btn-on-shelf { position: absolute; top: 5px; right: 5px; width: 24px; height: 24px; border-radius: 50%; border: none; background-color: rgba(220, 53, 69, 0.8); color: white; font-size: 14px; font-weight: bold; cursor: pointer; display: flex; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.2s; }
        .book-item:hover .delete-book-btn-on-shelf { opacity: 1; }

        .book-item .tag-book-btn { position: absolute; bottom: 35px; right: 5px; width: 24px; height: 24px; border-radius: 50%; border: none; background-color: rgba(0, 123, 255, 0.8); color: white; font-size: 14px; cursor: pointer; display: flex; justify-content: center; align-items: center; opacity: 0; transition: opacity 0.2s; padding: 0; }
        .book-item:hover .tag-book-btn { opacity: 1; }
        
        .reader-container { width: 100%; max-width: 800px; height: 100%; display: flex; flex-direction: column; margin: 0 auto; }
        #app-loader { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--bg-color); display: flex; justify-content: center; align-items: center; z-index: 9999; opacity: 1; transition: opacity 0.4s ease-out; color: var(--text-color); font-size: 18px; }
        #app-loader.hidden { opacity: 0; pointer-events: none; }

        header { padding: 5px 0; margin-bottom: 5px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; transition: opacity .3s, height .3s, padding .3s, margin .3s, visibility .3s; overflow: hidden; }
        #header-filename { text-align: center; margin: 0 0 5px 0; font-size: 1em; font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 0 10px; height: 1.2em; }
        .controls { display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap; }
        #file-input { display: none; }
        .control-button, #theme-selector { padding: 5px 10px; border: 1px solid var(--border-color); background-color: transparent; color: var(--text-color); border-radius: 4px; cursor: pointer; font-size: 14px; }
        #theme-selector { -webkit-appearance: none; appearance: none; }
        
        #search-bar { display: none; padding: 8px 5px; background-color: var(--highlight-bg); border-bottom: 1px solid var(--border-color); flex-shrink: 0; display: flex; gap: 5px; align-items: center; flex-wrap: wrap; }
        #search-bar input { flex-grow: 1; min-width: 120px; background-color: var(--bg-color); border: 1px solid var(--border-color); color: var(--text-color); padding: 5px; border-radius: 4px; }
        #search-bar button { padding: 5px 8px; border: 1px solid var(--border-color); background-color: transparent; color: var(--text-color); border-radius: 4px; cursor: pointer; font-size: 14px; flex-shrink: 0; }
        #search-bar button:disabled { opacity: 0.5; cursor: not-allowed; }
        #search-bar #btn-close-search { font-weight: bold; margin-left: auto; }
        #search-results-info { font-size: 14px; min-width: 50px; text-align: center; }
        .search-highlight { background-color: var(--search-highlight-bg); color: var(--search-highlight-text); border-radius: 2px; }
        .search-highlight.active { background-color: var(--search-highlight-active-bg); }

        .content-wrapper { flex-grow: 1; border: 1px solid var(--border-color); border-radius: 5px; position: relative; overflow: hidden; user-select: none; }
        #content-inner { display: flex; height: 100%; width: 300%; position: relative; left: 0; transition: transform 0.3s ease-out; }
        #content-inner.is-dragging { transition: none; }
        .page-container { width: 33.333%; height: 100%; flex-shrink: 0; }
        .page { width: 100%; height: 100%; box-sizing: border-box; padding: 20px; overflow-y: auto; text-align: justify; cursor: default; 
                font-size: var(--font-size); line-height: var(--line-height); letter-spacing: var(--letter-spacing); }
        .page p { margin-top: 0; }
        .page p:not(.blank-line) { margin-bottom: var(--paragraph-spacing); }
        .page p:not(.blank-line):hover { background-color: var(--highlight-bg); }
        .page p.chapter-title { font-weight: bold; font-size: 1.2em; text-align: center; margin-top: 1em; margin-bottom: 1.5em; }
        .dialogue { color: var(--dialogue-color); }
        img.epub-image { max-width: 100%; height: auto; display: block; margin: 8px auto; }
        body.hover-highlight-disabled .page p:not(.blank-line):hover { background-color: transparent; }
        body.dialogue-highlight-disabled .dialogue { color: var(--text-color); }

        footer { flex-shrink: 0; padding: 8px 15px; transition: opacity .3s, height .3s, padding .3s, visibility .3s; display: flex; justify-content: space-between; align-items: center; }
        #chapter-info { text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #page-info { text-align: right; white-space: nowrap; cursor: pointer; }
        #chapter-info, #page-info { font-size: 14px; opacity: 0.8; flex-basis: 50%; }
        .control-button:disabled { background-color: var(--button-disabled-bg); cursor: not-allowed; opacity: 0.7; }
        
        .reader-container.immersive-active header { height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; margin-bottom: 0; visibility: hidden; }
        .reader-container.immersive-active footer { height: 0; opacity: 0; padding-top: 0; padding-bottom: 0; visibility: hidden; }
        
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: var(--modal-bg); justify-content: center; align-items: center; }
        .modal-content { background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); padding: 20px; border-radius: 8px; width: 80%; max-width: 500px; max-height: 80vh; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .modal-header h2 { margin: 0; }
        .close-button { font-size: 24px; font-weight: bold; background: none; border: none; color: var(--text-color); cursor: pointer; }
        .modal-list { list-style-type: none; padding: 0; margin: 0; overflow-y: auto; }
        .modal-list li { padding: 10px 5px; border-bottom: 1px solid var(--border-color); cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .modal-list li:hover { background-color: var(--highlight-bg); }
        .modal-list .history-item-text { font-size: 0.9em; opacity: 0.8; flex-basis: 100%; margin-top: 5px; white-space: normal; cursor: text; }
        .modal-list-actions { display: flex; gap: 8px; align-items: center; margin-left: 10px; }
        .action-btn { padding: 2px 8px; border-radius: 4px; border: 1px solid var(--text-color); color: var(--text-color); background-color: transparent; cursor: pointer; font-size: 12px; }
        .delete-btn { border-color: var(--danger-color); color: var(--danger-color); }

        #tag-edit-modal-title { font-size: 1.1em; font-weight: bold; margin-bottom: 15px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #current-tags-list { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 20px; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; min-height: 30px;}
        .tag-pill { background-color: var(--button-bg); color: var(--button-text); padding: 4px 10px; border-radius: 12px; font-size: 14px; display: flex; align-items: center; gap: 6px; }
        .tag-pill .remove-tag-btn { background: none; border: none; color: var(--button-text); cursor: pointer; font-size: 16px; padding: 0; line-height: 1; }
        #add-tag-form { display: flex; gap: 8px; }
        #add-tag-form input { flex-grow: 1; }

        .setting-item, .ai-menu-group { display: flex; justify-content: space-between; align-items: center; padding: 12px 5px; border-bottom: 1px solid var(--border-color); flex-wrap: wrap; }
        .setting-item:last-child, .ai-menu-group:last-child { border-bottom: none; }
        .setting-item span { flex-shrink: 0; margin-right: 10px; }
        .setting-item input[type="text"], .setting-item input[type="password"], .setting-item input[type="number"], .setting-item textarea, .setting-item select { flex-grow: 1; min-width: 120px; background-color: var(--highlight-bg); border: 1px solid var(--border-color); color: var(--text-color); padding: 5px; border-radius: 4px; }
        .setting-item input[type="color"] { padding: 0; border: none; width: 40px; height: 24px; background: none; cursor: pointer; }
        .setting-item textarea { resize: vertical; min-height: 60px; width: 100%; flex-basis: 100%; margin-top: 8px; }
        .toggle-switch { position: relative; display: inline-block; width: 44px; height: 24px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(20px); }
        .setting-item.font-control { flex-wrap: nowrap; gap: 10px; }
        .setting-item.font-control > span:first-child { flex-basis: 50px; flex-shrink: 0; }
        .setting-item.font-control input[type="range"] { flex-grow: 1; margin: 0 5px; }
        .setting-item.font-control .slider-value { flex-basis: 60px; text-align: right; font-variant-numeric: tabular-nums; }
        .setting-item.font-control .reset-btn { padding: 2px 8px; font-size: 12px; }

        .modal-footer { margin-top: 15px; text-align: right; }
        #summary-content { white-space: pre-wrap; word-wrap: break-word; }
        #summary-choice-modal .controls, #translation-choice-modal .controls { display: flex; flex-direction: column; gap: 15px; align-items: stretch;}
        #summary-choice-modal .control-button, #translation-choice-modal .control-button { width: 100%; box-sizing: border-box; }
        .ai-menu-group > span { font-weight: bold; flex-basis: 100%; margin-bottom: 10px; }
        .ai-menu-group .button-group { display: flex; justify-content: space-around; width: 100%; gap: 10px; }
        .ai-menu-group .control-button { flex: 1; }

        /* Custom Background Image Styles */
        body.custom-background-active {
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
        }
        body.custom-background-active { --bg-color: rgba(253, 246, 227, 0.92); }
        body.custom-background-active.theme-dark { --bg-color: rgba(33, 37, 41, 0.92); }
        body.custom-background-active.theme-green { --bg-color: rgba(204, 232, 207, 0.92); }
        body.custom-background-active.theme-blue { --bg-color: rgba(224, 240, 248, 0.92); }
        body.custom-background-active.theme-gray { --bg-color: rgba(225, 225, 225, 0.92); }
    </style>
</head>
<body>
    <div id="app-loader"><span>正在加载...</span></div>

    <div id="app-container">
        <!-- Bookshelf View -->
        <div id="bookshelf-view">
            <div class="bookshelf-header">
                <h1>我的书架</h1>
                <div id="bookshelf-filter-container">
                    <label for="bookshelf-filter">分类:</label>
                    <select id="bookshelf-filter"></select>
                </div>
                <label for="file-input" class="control-button">打开文件</label>
                <label for="import-files-input" class="control-button">导入文件</label>
                <label for="import-folder-input" class="control-button">导入文件夹</label>
            </div>
            <div id="bookshelf-grid"></div>
        </div>

        <!-- Reader View -->
        <div class="reader-container" style="display: none;">
            <header>
                <p id="header-filename">请选择文件或从书架打开</p>
                <div class="controls">
                    <button id="btn-back-to-shelf" class="control-button">返回书架</button>
                    <input type="file" id="file-input" accept=".txt,.epub" style="display:none;">
                    <input type="file" id="import-files-input" accept=".txt,.epub" multiple style="display:none;">
                    <input type="file" id="import-folder-input" webkitdirectory style="display:none;">
                    <button id="btn-search" class="control-button">搜索</button>
                    <button id="btn-settings" class="control-button">设置</button>
                    <button id="btn-add-to-shelf" class="control-button" style="display: none;">添加到书架</button>
                    <button id="btn-immersive-mode" class="control-button">沉浸模式</button>
                    <button id="btn-catalog" class="control-button" style="display: none;">目录</button>
                    <button id="btn-ai-menu" class="control-button" style="display: none;">AI 功能</button>
                    <button id="btn-back-to-original" class="control-button" style="display: none;">返回原文</button>
                    <select id="theme-selector">
                        <option value="default">默认护眼</option><option value="theme-dark">暗黑模式</option>
                        <option value="theme-green">护眼绿</option><option value="theme-blue">静谧蓝</option>
                        <option value="theme-gray">简约灰</option>
                    </select>
                </div>
            </header>
            <div id="search-bar" style="display: none;">
                <input type="text" id="search-input" placeholder="输入关键词...">
                <button id="btn-search-chapter">本章</button>
                <button id="btn-search-all">全文</button>
                <button id="btn-search-prev" disabled>&lt;</button>
                <button id="btn-search-next" disabled>&gt;</button>
                <span id="search-results-info"></span>
                <button id="btn-close-search" title="关闭搜索">&times;</button>
            </div>
            <main class="content-wrapper" id="content-wrapper">
                <div id="content-inner">
                    <div class="page-container" id="prev-page-container"></div>
                    <div class="page-container" id="current-page-container"><div class="page"><p>请选择一个 .txt 或 .epub 文件开始阅读。</p></div></div>
                    <div class="page-container" id="next-page-container"></div>
                </div>
            </main>
            <footer id="footer">
                <span id="chapter-info"></span>
                <span id="page-info">-- / -- 页</span>
            </footer>
        </div>

        <!-- Modals -->
        <div id="catalog-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>章节目录</h2><button class="close-button">&times;</button></div><ul id="catalog-list" class="modal-list"></ul></div></div>
        
        <div id="tag-edit-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>编辑标签</h2>
                    <button class="close-button">&times;</button>
                </div>
                <div id="tag-edit-modal-body">
                    <div id="tag-edit-modal-title"></div>
                    <label>当前标签:</label>
                    <div id="current-tags-list"></div>
                    <label for="new-tag-input">添加新标签:</label>
                    <form id="add-tag-form">
                        <input type="text" id="new-tag-input" class="control-input" placeholder="输入后按回车或点击添加">
                        <button type="submit" id="btn-add-tag" class="control-button">添加</button>
                    </form>
                </div>
                 <div class="modal-footer">
                    <button id="btn-close-tag-modal" class="control-button">完成</button>
                </div>
            </div>
        </div>

        <div id="settings-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header"><h2>阅读设置</h2><button class="close-button">&times;</button></div>
                <div id="settings-list">
                    <div class="setting-item"><span>点击翻页</span><label class="toggle-switch"><input type="checkbox" id="toggle-click-page"><span class="slider"></span></label></div>
                    <div class="setting-item"><span>滑动翻页</span><label class="toggle-switch"><input type="checkbox" id="toggle-swipe-page"><span class="slider"></span></label></div>
                    <div class="setting-item"><span>段落悬停高亮</span><label class="toggle-switch"><input type="checkbox" id="toggle-hover-highlight"><span class="slider"></span></label></div>
                    <div class="setting-item"><span>对白文字标色</span><label class="toggle-switch"><input type="checkbox" id="toggle-dialogue-highlight"><span class="slider"></span></label></div>
                    <div class="setting-item"><span>自定义对白颜色</span><div style="display: flex; align-items: center; gap: 8px;"><input type="color" id="dialogue-color-picker"><button id="btn-reset-dialogue-color" class="control-button" style="padding: 2px 8px; font-size: 12px;">重置</button></div></div>
                    
                    <div class="setting-item">
                        <span>字体与排版</span><button id="btn-font-settings" class="control-button">调整</button>
                    </div>

                    <div class="setting-item">
                        <span>字体颜色</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="color" id="text-color-picker">
                            <button id="btn-reset-text-color" class="control-button" style="padding: 2px 8px; font-size: 12px;">重置</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <span>背景颜色</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="color" id="bg-color-picker">
                            <button id="btn-reset-bg-color" class="control-button" style="padding: 2px 8px; font-size: 12px;">重置</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <span>自定义背景图</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="bg-image-input" class="control-button" style="padding: 5px 8px;">选择</label>
                            <input type="file" id="bg-image-input" accept="image/*" style="display:none;">
                            <button id="btn-clear-bg-image" class="control-button">清除</button>
                        </div>
                    </div>
                    
                    <div class="setting-item"><span>AI 功能设置</span><button id="btn-ai-settings" class="control-button">配置</button></div>
                    <div class="setting-item" style="justify-content: center; padding-top: 20px;"><button id="btn-factory-reset" class="control-button" style="background-color: var(--danger-color); color: white;">恢复所有默认设置</button></div>
                </div>
            </div>
        </div>

        <div id="font-settings-modal" class="modal">
            <div class="modal-content">
                <div class="modal-header"><h2>字体与排版设置</h2><button class="close-button">&times;</button></div>
                <div id="font-settings-list">
                    <div class="setting-item font-control">
                        <span>字号</span>
                        <input type="range" id="font-size-slider" min="12" max="36" step="1">
                        <span id="font-size-value" class="slider-value">20px</span>
                        <button id="reset-font-size" class="control-button reset-btn">重置</button>
                    </div>
                    <div class="setting-item font-control">
                        <span>字距</span>
                        <input type="range" id="letter-spacing-slider" min="0" max="5" step="0.1">
                        <span id="letter-spacing-value" class="slider-value">0.0px</span>
                        <button id="reset-letter-spacing" class="control-button reset-btn">重置</button>
                    </div>
                    <div class="setting-item font-control">
                        <span>行距</span>
                        <input type="range" id="line-height-slider" min="1.2" max="3.0" step="0.1">
                        <span id="line-height-value" class="slider-value">1.9</span>
                        <button id="reset-line-height" class="control-button reset-btn">重置</button>
                    </div>
                    <div class="setting-item font-control">
                        <span>段距</span>
                        <input type="range" id="paragraph-spacing-slider" min="0.5" max="3.0" step="0.1">
                        <span id="paragraph-spacing-value" class="slider-value">1.0em</span>
                        <button id="reset-paragraph-spacing" class="control-button reset-btn">重置</button>
                    </div>
                    <div class="setting-item">
                        <span>自定义字体</span>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="font-file-input" class="control-button" style="padding: 5px 8px;">选择</label>
                            <input type="file" id="font-file-input" accept=".ttf,.otf,.woff,.woff2" style="display:none;">
                            <button id="btn-clear-font" class="control-button">清除</button>
                        </div>
                        <span id="custom-font-status" style="flex-basis: 100%; text-align: right; font-size: 12px; opacity: 0.7; margin-top: 5px;">未设置</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="ai-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>AI 功能设置</h2><button class="close-button">&times;</button></div><div class="ai-settings-list"><div class="setting-item"><span>API 地址</span><input type="text" id="ai-api-url" placeholder="例如: https://api.openai.com/v1/chat/completions"></div><div class="setting-item"><span>API Key</span><input type="password" id="ai-api-key"></div><div class="setting-item"><span>模型名称</span><input type="text" id="ai-model-name" placeholder="例如: gpt-3.5-turbo"></div><div class="setting-item"><span>总结最大字数</span><input type="number" id="ai-summary-length" placeholder="默认 100"></div><div class="setting-item"><span>自定义总结提示词</span><textarea id="ai-summary-prompt" placeholder="留空则使用默认提示词。"></textarea></div><div class="setting-item"><span>自定义翻译提示词</span><textarea id="ai-translation-prompt" placeholder="留空则使用默认提示词。"></textarea></div><div class="setting-item"><span>自定义续写提示词</span><textarea id="ai-sequel-prompt" placeholder="留空则使用默认提示词。"></textarea></div></div><div class="modal-footer"><button id="btn-save-ai-settings" class="control-button">保存</button></div></div></div>

        <div id="ai-menu-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>AI 功能菜单</h2><button class="close-button">&times;</button></div><div id="ai-menu-list"><div class="ai-menu-group"><span>内容生成</span><div class="button-group"><button id="btn-summary" class="control-button">总结</button><button id="btn-sequel" class="control-button">续写</button><button id="btn-translate" class="control-button">翻译</button></div></div><div class="ai-menu-group"><span>历史记录</span><div class="button-group"><button id="btn-summary-history" class="control-button">总结历史</button><button id="btn-sequel-history" class="control-button">续写历史</button><button id="btn-translation-history" class="control-button">翻译历史</button></div></div></div></div></div>
        
        <div id="summary-choice-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>选择总结范围</h2><button class="close-button">&times;</button></div><div class="controls"><button id="btn-summarize-page" class="control-button">总结当前页</button><button id="btn-summarize-chapter" class="control-button">总结所在章</button><button id="btn-summarize-range" class="control-button">总结页码区间</button></div></div></div>
        <div id="summary-display-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>AI 总结</h2><button class="close-button">&times;</button></div><div id="summary-content" class="page" style="height: auto; max-height: 60vh;">...</div><div class="modal-footer"><button id="btn-save-summary" class="control-button" style="display:none;">保存该总结</button></div></div></div>
        <div id="translation-choice-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>选择翻译范围</h2><button class="close-button">&times;</button></div><div class="controls"><button id="btn-translate-page" class="control-button">翻译当前页</button><button id="btn-translate-chapter" class="control-button">翻译所在章</button><button id="btn-translate-range" class="control-button">翻译页码区间</button></div></div></div>
        
        <div id="summary-history-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>总结历史</h2><button class="close-button">&times;</button></div><ul id="summary-history-list" class="modal-list"></ul></div></div>
        <div id="sequel-history-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>续写历史</h2><button class="close-button">&times;</button></div><ul id="sequel-history-list" class="modal-list"></ul></div></div>
        <div id="translation-history-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>翻译历史</h2><button class="close-button">&times;</button></div><ul id="translation-history-list" class="modal-list"></ul></div></div>

        <div id="sequel-choice-modal" class="modal"><div class="modal-content"><div class="modal-header"><h2>续写设置</h2><button class="close-button">&times;</button></div><div class="sequel-settings-list"><div class="setting-item"><span>续写范围类型</span><select id="sequel-range-type"><option value="page">页码</option><option value="chapter">章节</option></select></div><div class="setting-item" id="sequel-page-range-selector"><span>起止页码</span><input type="text" id="sequel-page-range" placeholder="例如: 10-12"></div><div class="setting-item" id="sequel-chapter-range-selector" style="display:none;"><span>起止章节</span><input type="text" id="sequel-chapter-range" placeholder="例如: 3-4 (章节序号)"></div><div class="setting-item"><span>选择参考总结 (可选, 可多选)</span></div><ul id="sequel-summary-context-list" class="modal-list" style="max-height: 20vh; border: 1px solid var(--border-color); padding: 5px; cursor: default;"></ul></div><div class="modal-footer"><button id="btn-generate-sequel" class="control-button">生成续写</button></div></div></div>

        <div id="calculation-ruler" style="visibility: hidden; position: absolute; top: -9999px; left: -9999px;"></div>
    </div>

    <script src="jszip.min.js"></script>

    <script>
        // --- DOM Elements ---
        const appContainer = document.getElementById('app-container'), bookshelfView = document.getElementById('bookshelf-view'),
            readerView = document.querySelector('.reader-container'), bookshelfGrid = document.getElementById('bookshelf-grid'),
            btnBackToShelf = document.getElementById('btn-back-to-shelf'), fileInput = document.getElementById('file-input'),
            contentWrapper = document.getElementById('content-wrapper'), contentInner = document.getElementById('content-inner'),
            pageInfo = document.getElementById('page-info'), 
            themeSelector = document.getElementById('theme-selector'), headerFilename = document.getElementById('header-filename'),
            ruler = document.getElementById('calculation-ruler'), footer = document.getElementById('footer'),
            prevPageContainer = document.getElementById('prev-page-container'), currentPageContainer = document.getElementById('current-page-container'),
            nextPageContainer = document.getElementById('next-page-container'), appLoader = document.getElementById('app-loader'),
            chapterInfoEl = document.getElementById('chapter-info');
        
        const importFilesInput = document.getElementById('import-files-input');
        const importFolderInput = document.getElementById('import-folder-input');

        const bookshelfFilter = document.getElementById('bookshelf-filter');
        const tagEditModal = document.getElementById('tag-edit-modal');
        const tagEditModalTitle = document.getElementById('tag-edit-modal-title');
        const currentTagsList = document.getElementById('current-tags-list');
        const addTagForm = document.getElementById('add-tag-form');
        const newTagInput = document.getElementById('new-tag-input');
        const btnCloseTagModal = document.getElementById('btn-close-tag-modal');

        const btnCatalog = document.getElementById('btn-catalog'), catalogModal = document.getElementById('catalog-modal'), catalogList = document.getElementById('catalog-list'),
            btnAddToShelf = document.getElementById('btn-add-to-shelf'), btnSettings = document.getElementById('btn-settings'),
            settingsModal = document.getElementById('settings-modal'), btnBackToOriginal = document.getElementById('btn-back-to-original');
        
        const toggleClickPage = document.getElementById('toggle-click-page'), toggleSwipePage = document.getElementById('toggle-swipe-page'),
            fontFileInput = document.getElementById('font-file-input'), btnClearFont = document.getElementById('btn-clear-font'),
            customFontStatus = document.getElementById('custom-font-status'),
            toggleHoverHighlight = document.getElementById('toggle-hover-highlight'), toggleDialogueHighlight = document.getElementById('toggle-dialogue-highlight'),
            dialogueColorPicker = document.getElementById('dialogue-color-picker'), btnResetDialogueColor = document.getElementById('btn-reset-dialogue-color'),
            btnFactoryReset = document.getElementById('btn-factory-reset');
            
        const textColorPicker = document.getElementById('text-color-picker'), btnResetTextColor = document.getElementById('btn-reset-text-color'),
            bgColorPicker = document.getElementById('bg-color-picker'), btnResetBgColor = document.getElementById('btn-reset-bg-color'),
            bgImageInput = document.getElementById('bg-image-input'), btnClearBgImage = document.getElementById('btn-clear-bg-image');

        const btnFontSettings = document.getElementById('btn-font-settings'), fontSettingsModal = document.getElementById('font-settings-modal');
        const btnImmersiveMode = document.getElementById('btn-immersive-mode');

        const fontSizeSlider = document.getElementById('font-size-slider'), fontSizeValue = document.getElementById('font-size-value'),
            resetFontSize = document.getElementById('reset-font-size'), letterSpacingSlider = document.getElementById('letter-spacing-slider'),
            letterSpacingValue = document.getElementById('letter-spacing-value'), resetLetterSpacing = document.getElementById('reset-letter-spacing'),
            lineHeightSlider = document.getElementById('line-height-slider'), lineHeightValue = document.getElementById('line-height-value'),
            resetLineHeight = document.getElementById('reset-line-height'), paragraphSpacingSlider = document.getElementById('paragraph-spacing-slider'),
            paragraphSpacingValue = document.getElementById('paragraph-spacing-value'), resetParagraphSpacing = document.getElementById('reset-paragraph-spacing');

        const btnAiMenu = document.getElementById('btn-ai-menu'), aiMenuModal = document.getElementById('ai-menu-modal'),
            btnAiSettings = document.getElementById('btn-ai-settings'), aiSettingsModal = document.getElementById('ai-settings-modal'),
            aiApiUrlInput = document.getElementById('ai-api-url'), aiApiKeyInput = document.getElementById('ai-api-key'),
            aiModelNameInput = document.getElementById('ai-model-name'), aiSummaryLengthInput = document.getElementById('ai-summary-length'),
            aiSummaryPromptInput = document.getElementById('ai-summary-prompt'), aiTranslationPromptInput = document.getElementById('ai-translation-prompt'),
            aiSequelPromptInput = document.getElementById('ai-sequel-prompt'), btnSaveAiSettings = document.getElementById('btn-save-ai-settings');
        
        const btnSummary = document.getElementById('btn-summary'), btnSequel = document.getElementById('btn-sequel'), btnTranslate = document.getElementById('btn-translate');
        const btnSummaryHistory = document.getElementById('btn-summary-history'), btnSequelHistory = document.getElementById('btn-sequel-history'), btnTranslationHistory = document.getElementById('btn-translation-history');
        
        const summaryChoiceModal = document.getElementById('summary-choice-modal'), btnSummarizePage = document.getElementById('btn-summarize-page'), btnSummarizeChapter = document.getElementById('btn-summarize-chapter'), btnSummarizeRange = document.getElementById('btn-summarize-range');
        const summaryDisplayModal = document.getElementById('summary-display-modal'), summaryContent = document.getElementById('summary-content'), btnSaveSummary = document.getElementById('btn-save-summary');
        const translationChoiceModal = document.getElementById('translation-choice-modal'), btnTranslatePage = document.getElementById('btn-translate-page'), btnTranslateChapter = document.getElementById('btn-translate-chapter'), btnTranslateRange = document.getElementById('btn-translate-range');
        const sequelChoiceModal = document.getElementById('sequel-choice-modal'), sequelRangeType = document.getElementById('sequel-range-type'), sequelPageRangeSelector = document.getElementById('sequel-page-range-selector'), sequelChapterRangeSelector = document.getElementById('sequel-chapter-range-selector'), sequelPageRangeInput = document.getElementById('sequel-page-range'), sequelChapterRangeInput = document.getElementById('sequel-chapter-range'), sequelSummaryContextList = document.getElementById('sequel-summary-context-list'), btnGenerateSequel = document.getElementById('btn-generate-sequel');
        const summaryHistoryModal = document.getElementById('summary-history-modal'), summaryHistoryList = document.getElementById('summary-history-list');
        const sequelHistoryModal = document.getElementById('sequel-history-modal'), sequelHistoryList = document.getElementById('sequel-history-list');
        const translationHistoryModal = document.getElementById('translation-history-modal'), translationHistoryList = document.getElementById('translation-history-list');

        // --- Search Elements ---
        const btnSearch = document.getElementById('btn-search'), searchBar = document.getElementById('search-bar'),
            searchInput = document.getElementById('search-input'), btnSearchChapter = document.getElementById('btn-search-chapter'),
            btnSearchAll = document.getElementById('btn-search-all'), btnSearchPrev = document.getElementById('btn-search-prev'),
            btnSearchNext = document.getElementById('btn-search-next'), searchResultsInfo = document.getElementById('search-results-info'),
            btnCloseSearch = document.getElementById('btn-close-search');

        // --- State ---
        let currentFileName = '', currentFileContent = '', currentPage = 1, totalPages = 0, chapters = [], originalParagraphs = [], allRenderedPages = [], bookshelf = [];
        let currentBookCoverUrl = null, currentBookData = { summaries: [], sequels: [], translations: [] };
        let isDragging = false, dragStartX = 0, currentTranslate = 0, dragDelta = 0, viewportWidth = 0;
        let isShelfDragging = false, shelfStartY = 0, shelfScrollTopStart = 0;
        let isTransitioning = false, ignoreNextClick = false;
        let settings = {
            enableClickPage: true, enableSwipePage: true, enableHoverHighlight: true, enableDialogueHighlight: true, dialogueCustomColor: null,
            customTextColor: null, customBgColor: null,
            fontSize: 20, letterSpacing: 0, lineHeight: 1.9, paragraphSpacing: 1.0,
        };
        const defaultFontSettings = { fontSize: 20, letterSpacing: 0, lineHeight: 1.9, paragraphSpacing: 1.0 };
        let aiSettings = { apiUrl: '', apiKey: '', modelName: '', summaryLength: 100, summaryPrompt: '', translationPrompt: '', sequelPrompt: '' };
        let currentCustomFontUrl = null, currentBgImageUrl = null;
        let activeSubView = 'original'; // 'original', 'translation', 'sequel'
        let originalContentForSubView = { name: '', content: '' };
        let createdBlobUrls = [], epubImagePreloadList = [];
        let tempSummaryHolder = { text: '', range: '' };
        let searchResults = [], currentSearchIndex = -1;
        let fontSettingsChanged = false;
        let isInImmersiveMode = false;
        let activeFilterTag = null;
        let bookNameToEditTags = null;

        // --- View Management & Data ---
        function showReaderView() { bookshelfView.style.display = 'none'; readerView.style.display = 'flex'; }
        function showBookshelfView() { 
            readerView.style.display = 'none'; 
            bookshelfView.style.display = 'flex'; 
            populateFilterDropdown();
            renderBookshelf(); 
            if (isInImmersiveMode) {
                isInImmersiveMode = false;
                readerView.classList.remove('immersive-active');
            }
        }
        function cleanupBlobUrls() { try { createdBlobUrls.forEach(u => URL.revokeObjectURL(u)); } catch(e) {} createdBlobUrls = []; epubImagePreloadList = []; }
        function loadBookData() { if (!currentFileName) { currentBookData = { summaries: [], sequels: [], translations: [] }; return; } try { const data = localStorage.getItem(`novelReaderData_${currentFileName}`); currentBookData = data ? JSON.parse(data) : { summaries: [], sequels: [], translations: [] }; if (!currentBookData.summaries) currentBookData.summaries = []; if (!currentBookData.sequels) currentBookData.sequels = []; if (!currentBookData.translations) currentBookData.translations = []; } catch (e) { console.error("Failed to load book data:", e); currentBookData = { summaries: [], sequels: [], translations: [] }; } }
        function saveBookData() { if (currentFileName) localStorage.setItem(`novelReaderData_${currentFileName}`, JSON.stringify(currentBookData)); }

        // --- EPUB Parsing (Unchanged) ---
        function isEpubFile(file) { return /\.epub$/i.test(file.name) || file.type === 'application/epub+zip'; }
        function parseXml(text) { return new DOMParser().parseFromString(text, 'application/xml'); }
        function parseHtmlLike(text) { let doc = new DOMParser().parseFromString(text, 'text/html'); if (!doc || !doc.body || doc.body.childNodes.length === 0) { doc = new DOMParser().parseFromString(text, 'application/xhtml+xml'); } return doc; }
        function resolvePath(baseDir, relativePath) { const url = new URL(relativePath, 'http://local/' + (baseDir ? baseDir.replace(/\/?$/, '/') : '')); return url.pathname.replace(/^\//, ''); }
        function inferMimeByPath(path) { const ext = (path.split('.').pop() || '').toLowerCase(); switch (ext) { case 'jpg': case 'jpeg': return 'image/jpeg'; case 'png': return 'image/png'; case 'gif': return 'image/gif'; case 'webp': return 'image/webp'; case 'svg': return 'image/svg+xml'; default: return 'application/octet-stream'; } }
        async function makeImageBlobUrl(zip, fullPath, mime) { const entry = zip.file(fullPath); if (!entry) return null; const ab = await entry.async('arraybuffer'); const url = URL.createObjectURL(new Blob([ab], { type: mime || inferMimeByPath(fullPath) })); return url; }
        function escapeHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
        async function parseEpubToPlainText(file) { 
            const zip = await JSZip.loadAsync(file); 
            const containerPath = 'META-INF/container.xml'; const containerFile = zip.file(containerPath); if (!containerFile) throw new Error('未找到 META-INF/container.xml'); const containerXml = await containerFile.async('string'); const containerDoc = parseXml(containerXml); const rootfileEl = containerDoc.querySelector('rootfile'); if (!rootfileEl) throw new Error('EPUB: 未找到 rootfile'); const opfPath = rootfileEl.getAttribute('full-path'); if (!opfPath) throw new Error('EPUB: container.xml 中缺少 full-path'); const opfDir = opfPath.includes('/') ? opfPath.slice(0, opfPath.lastIndexOf('/') + 1) : ''; const opfText = await zip.file(opfPath).async('string'); const opfDoc = parseXml(opfText); const manifest = {}; opfDoc.querySelectorAll('manifest > item').forEach(item => { manifest[item.getAttribute('id')] = { id: item.getAttribute('id'), href: item.getAttribute('href'), mediaType: item.getAttribute('media-type'), properties: item.getAttribute('properties') || '' }; }); const manifestByFullPath = {}; Object.values(manifest).forEach(it => { manifestByFullPath[resolvePath(opfDir, it.href)] = it; }); let coverUrl = null; const metaCover = opfDoc.querySelector('metadata > meta[name="cover"]'); let coverId = metaCover ? metaCover.getAttribute('content') : null; if (!coverId) { const coverItem = opfDoc.querySelector('manifest > item[properties~="cover-image"]'); if (coverItem) coverId = coverItem.getAttribute('id'); } if (coverId) { const coverManifestItem = manifest[coverId]; if (coverManifestItem) { const coverPath = resolvePath(opfDir, coverManifestItem.href); coverUrl = await makeImageBlobUrl(zip, coverPath, coverManifestItem.mediaType); } } const spineIds = Array.from(opfDoc.querySelectorAll('spine > itemref')).map(el => el.getAttribute('idref')); const titleByHref = {}; const navItem = Object.values(manifest).find(it => (it.properties || '').split(/\s+/).includes('nav')); if (navItem) { const navFullPath = resolvePath(opfDir, navItem.href); const navEntry = zip.file(navFullPath); if (navEntry) { const navDoc = parseHtmlLike(await navEntry.async('string')); navDoc.querySelectorAll('nav[epub\\:type="toc"] ol a[href], nav[role="doc-toc"] ol a[href]').forEach(a => { const clean = resolvePath(opfDir, a.getAttribute('href') || '').split('#')[0]; if (a.textContent.trim()) titleByHref[clean] = a.textContent.trim(); }); } } const IMG_MARK = ':::EPUB_IMG:::'; let lines = []; let isFirstImage = true; for (let idref of spineIds) { const item = manifest[idref]; if (!item || !/html|xhtml/.test(item.mediaType || '')) continue; const htmlPath = resolvePath(opfDir, item.href); const html = await zip.file(htmlPath)?.async('string'); if (!html) continue; const doc = parseHtmlLike(html); let chapterTitle = titleByHref[htmlPath] || (doc.querySelector('h1,h2,h3,h4,h5,h6,title')?.textContent || '').trim(); if (chapterTitle) { lines.push(chapterTitle.trim(), ''); } const nodes = doc.body.querySelectorAll('h1,h2,h3,h4,h5,h6,figure,img,p,blockquote,pre'); for (const el of nodes) { const tag = el.tagName.toUpperCase(); if (/^H[1-6]$/.test(tag)) continue; const processImage = async (imgEl) => { let src = imgEl.getAttribute('src') || ''; if (!src) return null; const cleanPath = resolvePath(htmlPath.substring(0, htmlPath.lastIndexOf('/') + 1), src).split('#')[0]; const manifestItem = manifestByFullPath[cleanPath]; const imgBlobUrl = await makeImageBlobUrl(zip, cleanPath, manifestItem?.mediaType); if (imgBlobUrl) { if (isFirstImage && !coverUrl) { coverUrl = imgBlobUrl; isFirstImage = false; } createdBlobUrls.push(imgBlobUrl); epubImagePreloadList.push(imgBlobUrl); } return imgBlobUrl ? {url: imgBlobUrl, alt: (imgEl.getAttribute('alt') || '').trim()} : null; }; if (tag === 'FIGURE') { const img = el.querySelector('img'); if (img) { const imgData = await processImage(img); if (imgData) { lines.push(`${IMG_MARK}${encodeURIComponent(imgData.url)}|${encodeURIComponent(imgData.alt)}`); const cap = (el.querySelector('figcaption')?.textContent || '').trim(); if (cap) lines.push(cap); lines.push(''); } } } else if (tag === 'IMG' && !el.closest('figure')) { const imgData = await processImage(el); if (imgData) { lines.push(`${IMG_MARK}${encodeURIComponent(imgData.url)}|${encodeURIComponent(imgData.alt)}`, ''); } } else if (['P', 'BLOCKQUOTE', 'PRE'].includes(tag) && (!el.children.length || el.children[0].tagName.toUpperCase() !== 'IMG')) { const text = (el.textContent || '').replace(/\s+\n/g, '\n').replace(/\u00A0/g, ' ').replace(/[ \t]{2,}/g, ' ').trim(); if (text) lines.push(text); } } if (lines[lines.length - 1] !== '') lines.push(''); } const fullText = lines.join('\n'); if (!fullText.trim()) throw new Error('EPUB 解析结果为空'); return { textContent: fullText, coverUrl: coverUrl }; }
        
        // --- Core Application Logic ---
        function readFileAsText(file, encoding) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = () => reject(reader.error); reader.readAsText(file, encoding); }); }
        async function preloadImages(urls, timeoutMs = 2000) { return new Promise(resolve => { if (!urls || urls.length === 0) return resolve(); let loaded = 0, done = false; const finish = () => { if (!done) { done = true; resolve(); } }; const timer = setTimeout(finish, timeoutMs); urls.forEach(u => { const img = new Image(); img.onload = img.onerror = () => { if (++loaded >= urls.length) { clearTimeout(timer); finish(); } }; img.src = u; }); }); }
        async function loadBookFromFile(event) { const file = event.target.files[0]; if (!file) return; showReaderView(); activeSubView = 'original'; currentBookCoverUrl = null; cleanupBlobUrls(); if (isEpubFile(file)) { try { appLoader.classList.remove('hidden'); appLoader.querySelector('span').textContent = '正在解析 EPUB...'; const { textContent: epubText, coverUrl } = await parseEpubToPlainText(file); currentBookCoverUrl = coverUrl; await loadBook(file.name, epubText); } catch (err) { console.error('EPUB 解析失败:', err); alert('解析 EPUB 失败：' + (err?.message || err)); showBookshelfView(); } finally { appLoader.classList.add('hidden'); appLoader.querySelector('span').textContent = '正在加载...'; } return; } let text; try { text = await readFileAsText(file, 'UTF-8'); if (text.includes('\uFFFD')) { throw new Error("Fallback to GBK."); } } catch (error) { try { text = await readFileAsText(file, 'GBK'); } catch (fallbackError) { alert("无法读取文件。"); showBookshelfView(); return; } } loadBook(file.name, text); }
        async function loadBookFromShelf(bookName) {
            const bookMeta = bookshelf.find(b => b.name === bookName);
            if (bookMeta) {
                appLoader.classList.remove('hidden');
                appLoader.querySelector('span').textContent = '正在从书库加载...';
                try {
                    const book = await storageDB.loadBook(bookName);
                    if (book) {
                        activeSubView = 'original';
                        currentBookCoverUrl = null; // Covers are data URLs in metadata
                        showReaderView();
                        await loadBook(book.id, book.content);
                    } else {
                        throw new Error("在数据库中未找到书籍内容。");
                    }
                } catch(err) {
                    console.error("从书库加载书籍失败:", err);
                    alert(`加载《${bookName}》失败: ${err.message}`);
                } finally {
                     appLoader.classList.add('hidden');
                }
            }
        }
        async function loadBook(fileName, content, options = {}) { clearSearch(); currentFileName = fileName; currentFileContent = content; document.title = currentFileName; headerFilename.textContent = currentFileName; if (activeSubView === 'original') { loadBookData(); } updatePageInfo(0, 0, true); prepareContent(content); await preloadImages(epubImagePreloadList, 2000); await new Promise(resolve => setTimeout(() => paginate().then(resolve), 50)); let startPage = 1; if (activeSubView === 'original' && !options.isRepagination) { const savedPage = loadProgress(currentFileName); if(savedPage) startPage = savedPage; } currentPage = options.startPage || ((startPage > 0 && startPage <= totalPages) ? startPage : 1); updateDOMPages(); updateUI(); updateHeaderForState(); return Promise.resolve(); }
        function prepareContent(text) { chapters = []; const chapterRegex = /^(第\s*[一二三四五六七八九十百千\d\s]+[章回节卷])|^(Chapter\s+\d+)|(^\d{1,3}\s+)/; const dialogueRegex = /(“[^”]*”|「[^」]*」)/g; const IMG_MARK = ':::EPUB_IMG:::'; originalParagraphs = (text || '').split(/\r?\n/).map((pText, index) => { const p = document.createElement('p'); p.dataset.originalIndex = index; const trimmedText = pText.trim(); if (trimmedText.startsWith(IMG_MARK)) { const [urlEnc, altEnc = ''] = trimmedText.slice(IMG_MARK.length).split('|'); p.classList.add('epub-image-paragraph'); p.innerHTML = `<img class="epub-image" src="${decodeURIComponent(urlEnc || '')}" alt="${escapeHtml(decodeURIComponent(altEnc || ''))}">`; } else if (trimmedText === '') { p.classList.add('blank-line'); p.innerHTML = '&nbsp;'; } else { if (chapterRegex.test(trimmedText) && trimmedText.length < 50) { const chapId = `chap-${index}`; chapters.push({ title: trimmedText, p_id: chapId, p_index: index, chap_num: chapters.length + 1 }); p.id = chapId; p.classList.add('chapter-title'); } p.innerHTML = escapeHtml(pText).replace(dialogueRegex, `<span class="dialogue">$&</span>`); } return p; }); populateCatalog(); }
        async function paginate() {
            return new Promise(resolve => {
                viewportWidth = contentWrapper.clientWidth;
                if (viewportWidth === 0) { setTimeout(() => paginate().then(resolve), 50); return; }
                
                ruler.className = 'page';
                ruler.style.width = viewportWidth + 'px';
                ruler.style.height = contentWrapper.clientHeight + 'px';
                ruler.style.fontFamily = getComputedStyle(document.body).fontFamily;

                allRenderedPages = [];
                let currentPageParas = [];
                const createPage = (paras) => { if (paras.length === 0) return; const pageDiv = document.createElement('div'); pageDiv.className = 'page'; paras.forEach(p => pageDiv.appendChild(p.cloneNode(true))); allRenderedPages.push(pageDiv); };

                for (const p of originalParagraphs) {
                    if (p.id && p.id.startsWith('chap-') && currentPageParas.length > 0) { createPage(currentPageParas); currentPageParas = []; }
                    if (currentPageParas.length === 0 && p.classList.contains('blank-line')) continue;
                    
                    ruler.innerHTML = '';
                    [...currentPageParas, p].forEach(testP => ruler.appendChild(testP.cloneNode(true)));
                    
                    if (ruler.scrollHeight > ruler.clientHeight) {
                        createPage(currentPageParas);
                        currentPageParas = p.classList.contains('blank-line') ? [] : [p];
                    } else { currentPageParas.push(p); }
                }
                createPage(currentPageParas);
                totalPages = allRenderedPages.length;
                
                ruler.className = '';
                resolve();
            });
        }
        function updateDOMPages() { prevPageContainer.innerHTML = ''; currentPageContainer.innerHTML = ''; nextPageContainer.innerHTML = ''; if (allRenderedPages.length > 0 && allRenderedPages[currentPage - 1]) currentPageContainer.appendChild(allRenderedPages[currentPage - 1]); else currentPageContainer.innerHTML = '<div class="page"><p>无内容</p></div>'; if (currentPage > 1 && allRenderedPages[currentPage - 2]) prevPageContainer.appendChild(allRenderedPages[currentPage - 2]); if (currentPage < totalPages && allRenderedPages[currentPage]) nextPageContainer.appendChild(allRenderedPages[currentPage]); contentInner.classList.add('is-dragging'); currentTranslate = -viewportWidth; contentInner.style.transform = `translateX(${currentTranslate}px)`; contentInner.offsetHeight; contentInner.classList.remove('is-dragging'); }
        function jumpToPage(page) { if (page < 1 || page > totalPages || page === currentPage || isTransitioning) return; const isAdjacent = Math.abs(currentPage - page) === 1; if (isAdjacent) { const direction = page > currentPage ? 1 : -1; isTransitioning = true; currentTranslate += -direction * viewportWidth; contentInner.style.transform = `translateX(${currentTranslate}px)`; setTimeout(() => { currentPage = page; updateDOMPages(); updateUI(); if (activeSubView === 'original') saveProgress(currentFileName, currentPage); isTransitioning = false; }, 300); } else { currentPage = page; updateDOMPages(); updateUI(); if (activeSubView === 'original') saveProgress(currentFileName, currentPage); } }
        
        function getChapterInfoForPage(pageNumber) {
            if (chapters.length === 0 || !allRenderedPages[pageNumber - 1]) return null;

            const firstPOnPage = allRenderedPages[pageNumber - 1].querySelector("p[data-original-index]");
            if (!firstPOnPage) return null;
            const pIndex = parseInt(firstPOnPage.dataset.originalIndex, 10);

            let currentChap = null;
            for (let i = chapters.length - 1; i >= 0; i--) {
                if (chapters[i].p_index <= pIndex) {
                    currentChap = chapters[i];
                    break;
                }
            }
            if (!currentChap) return null;

            const nextChap = chapters.find(c => c.chap_num === currentChap.chap_num + 1);

            const findPageForPIndex = (idx) => {
                for(let i = 0; i < allRenderedPages.length; i++) {
                    const firstP = allRenderedPages[i].querySelector("p[data-original-index]");
                    if (firstP && parseInt(firstP.dataset.originalIndex, 10) >= idx) {
                        return i + 1;
                    }
                }
                return totalPages;
            };

            const chapterStartPage = findPageForPIndex(currentChap.p_index);
            const chapterEndPage = nextChap ? findPageForPIndex(nextChap.p_index) -1 : totalPages;
            
            const totalPagesInChapter = (chapterEndPage - chapterStartPage) + 1;
            const currentPageInChapter = pageNumber - chapterStartPage + 1;
            
            if (currentPageInChapter < 1 || currentPageInChapter > totalPagesInChapter) return null;

            return {
                title: currentChap.title,
                current: currentPageInChapter,
                total: totalPagesInChapter
            };
        }

        function updateUI() {
            if (totalPages === 0 && currentFileName === '') {
                updatePageInfo('-', '-');
                chapterInfoEl.textContent = '';
                return;
            }
            updatePageInfo(currentPage, totalPages);
            
            const chapInfo = getChapterInfoForPage(currentPage);
            if (chapInfo) {
                chapterInfoEl.textContent = `${chapInfo.title} (${chapInfo.current}/${chapInfo.total})`;
                chapterInfoEl.title = `${chapInfo.title} (本章第 ${chapInfo.current} 页 / 共 ${chapInfo.total} 页)`;
                chapterInfoEl.style.visibility = 'visible';
            } else {
                chapterInfoEl.textContent = '';
                chapterInfoEl.style.visibility = 'hidden';
            }
        }
        function updatePageInfo(current, total, isPaginating = false) { 
            if (isPaginating) { 
                pageInfo.textContent = '排版中...'; 
                appLoader.classList.remove('hidden'); 
                return; 
            } 
            appLoader.classList.add('hidden'); 
            pageInfo.textContent = `${current} / ${total} 页`; 
        }

        // --- Bookshelf & Catalog ---
        function loadBookshelf() { 
            const data = localStorage.getItem('novelReaderBookshelf'); 
            // The bookshelf now only contains metadata
            bookshelf = data ? JSON.parse(data) : []; 
            bookshelf.forEach(book => {
                if (!book.tags) book.tags = [];
            });
        }
        function saveBookshelf() { 
            // We are only saving metadata here, which is much faster.
            localStorage.setItem('novelReaderBookshelf', JSON.stringify(bookshelf)); 
        }
        
        function populateFilterDropdown() {
            const allTags = new Set();
            bookshelf.forEach(book => {
                (book.tags || []).forEach(tag => allTags.add(tag));
            });

            bookshelfFilter.innerHTML = '<option value="">全部</option>';
            allTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                bookshelfFilter.appendChild(option);
            });
            bookshelfFilter.value = activeFilterTag || '';
        }

        function renderBookshelf() { 
            bookshelfGrid.innerHTML = ''; 

            let booksToRender = bookshelf;
            if (activeFilterTag) {
                booksToRender = bookshelf.filter(b => b.tags && b.tags.includes(activeFilterTag));
            }

            if (booksToRender.length === 0) {
                const message = activeFilterTag 
                    ? `在“${escapeHtml(activeFilterTag)}”分类下没有书籍。`
                    : '书架是空的，请通过“导入”按钮添加书籍。';
                bookshelfGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: var(--text-color);">${message}</p>`;
                return;
            }

            booksToRender.forEach(book => {
                const bookEl = document.createElement('div'); 
                bookEl.className = 'book-item'; 
                bookEl.dataset.bookName = book.name; 
                bookEl.dataset.hasCover = !!book.cover; 
                const coverEl = document.createElement('div'); 
                coverEl.className = 'book-cover'; 
                if (book.cover) { 
                    coverEl.style.backgroundImage = `url(${book.cover})`; 
                } else { 
                    coverEl.textContent = book.name.substring(0, 30); 
                } 
                const titleEl = document.createElement('div'); 
                titleEl.className = 'book-title'; 
                titleEl.textContent = book.name; 
                const deleteBtn = document.createElement('button'); 
                deleteBtn.className = 'delete-book-btn-on-shelf'; 
                deleteBtn.innerHTML = '&times;'; 
                deleteBtn.dataset.bookName = book.name; 
                deleteBtn.title = '从书架删除'; 
                
                const tagBtn = document.createElement('button');
                tagBtn.className = 'tag-book-btn';
                tagBtn.innerHTML = '🏷️';
                tagBtn.dataset.bookName = book.name;
                tagBtn.title = '编辑标签';
                bookEl.append(coverEl, titleEl, deleteBtn, tagBtn);

                bookshelfGrid.appendChild(bookEl); 
            }); 
        }
        async function blobUrlToDataUrl(blobUrl) { if (!blobUrl) return null; const response = await fetch(blobUrl); const blob = await response.blob(); return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onloadend = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); }); }
        
        async function handleAddToShelf() { 
            if (!currentFileName || !currentFileContent) return; 
            if (bookshelf.some(b => b.name === currentFileName)) return; 
            
            const coverDataUrl = await blobUrlToDataUrl(currentBookCoverUrl);
            const bookMetadata = { name: currentFileName, cover: coverDataUrl, tags: [] };
            const bookContent = { id: currentFileName, content: currentFileContent };
            
            try {
                await storageDB.saveBook(bookContent);
                bookshelf.push(bookMetadata);
                saveBookshelf(); 
                updateAddToShelfButton(); 
            } catch(e) {
                console.error("添加到书架失败:", e);
                alert("添加到书架失败: " + e.message);
            }
        }
        
        bookshelfGrid.addEventListener('click', async (event) => {
            if (ignoreNextClick) {
                event.preventDefault();
                event.stopPropagation();
                ignoreNextClick = false;
                return;
            }

            const target = event.target;
            const bookName = target.closest('.book-item')?.dataset.bookName;

            if (target.classList.contains('tag-book-btn')) {
                event.stopPropagation();
                openTagEditModal(bookName);
            } else if (target.classList.contains('delete-book-btn-on-shelf')) {
                event.stopPropagation();
                if (confirm(`确定要从书架删除《${bookName}》吗？\n\n这将一并删除该书所有的阅读进度和AI历史记录(总结、续写、翻译)。此操作无法撤销。`)) {
                    try {
                        await storageDB.deleteBook(bookName);
                        bookshelf = bookshelf.filter(b => b.name !== bookName);
                        saveBookshelf();
                        localStorage.removeItem(`novelReaderData_${bookName}`);
                        localStorage.removeItem(`novelReaderProgress_${bookName}`);
                        populateFilterDropdown();
                        renderBookshelf();
                    } catch (e) {
                        console.error(`删除书籍 ${bookName} 失败:`, e);
                        alert(`删除书籍失败: ${e.message}`);
                    }
                }
            } else if (bookName) {
                await loadBookFromShelf(bookName);
            }
        });
        
        function updateAddToShelfButton() { if (!currentFileName) { btnAddToShelf.style.display = 'none'; return; } btnAddToShelf.style.display = 'inline-block'; const exists = bookshelf.some(b => b.name === currentFileName); btnAddToShelf.textContent = exists ? '已在书架' : '添加到书架'; btnAddToShelf.disabled = exists; }
        function populateCatalog() { catalogList.innerHTML = ''; if (chapters.length > 0) { btnCatalog.style.display = 'inline-block'; chapters.forEach(chap => { const li = document.createElement('li'); li.textContent = chap.title; li.dataset.pId = chap.p_id; catalogList.appendChild(li); }); } else { btnCatalog.style.display = 'none'; } }
        function handleCatalogClick(event) { if (event.target.tagName !== 'LI') return; const pId = event.target.dataset.pId; let targetPage = -1; for (let i = 0; i < allRenderedPages.length; i++) { if (allRenderedPages[i].querySelector(`#${pId}`)) { targetPage = i + 1; break; } } if (targetPage !== -1) { catalogModal.style.display = 'none'; jumpToPage(targetPage); } }
        
        async function handleFileImport(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            appLoader.classList.remove('hidden');
            
            const newBooksMetadata = [];
            const contentSavePromises = [];
            let skippedCount = 0;

            const filesToProcess = files.filter(file => {
                const isValidType = /\.(txt|epub)$/i.test(file.name);
                const isNew = !bookshelf.some(b => b.name === file.name);
                if (!isValidType || !isNew) skippedCount++;
                return isValidType && isNew;
            });

            let processedCount = 0;
            const totalToProcess = filesToProcess.length;

            for (const file of filesToProcess) {
                processedCount++;
                appLoader.querySelector('span').textContent = `正在处理 (${processedCount}/${totalToProcess}): ${file.name}`;
                
                await new Promise(resolve => setTimeout(resolve, 10)); 

                try {
                    let content;
                    let coverDataUrl = null;
                    cleanupBlobUrls(); 

                    if (isEpubFile(file)) {
                        const epubData = await parseEpubToPlainText(file);
                        content = epubData.textContent;
                        coverDataUrl = await blobUrlToDataUrl(epubData.coverUrl);
                        cleanupBlobUrls();
                    } else {
                        try {
                            content = await readFileAsText(file, 'UTF-8');
                            if (content.includes('\uFFFD')) { throw new Error("Fallback to GBK."); }
                        } catch (error) {
                            content = await readFileAsText(file, 'GBK');
                        }
                    }

                    newBooksMetadata.push({ name: file.name, cover: coverDataUrl, tags: [] });
                    contentSavePromises.push(storageDB.saveBook({ id: file.name, content: content }));

                } catch (err) {
                    console.error(`导入文件失败: ${file.name}`, err);
                    skippedCount++; 
                    cleanupBlobUrls();
                }
            }

            appLoader.querySelector('span').textContent = `正在写入数据库...`;
            await Promise.all(contentSavePromises);

            appLoader.querySelector('span').textContent = `正在更新书架...`;
            await new Promise(resolve => setTimeout(resolve, 50));

            bookshelf.push(...newBooksMetadata);
            saveBookshelf();
            populateFilterDropdown();
            renderBookshelf();

            appLoader.classList.add('hidden');
            appLoader.querySelector('span').textContent = '正在加载...';
            alert(`导入完成。\n成功: ${newBooksMetadata.length} 本\n跳过 (已存在或格式错误): ${skippedCount} 个`);
            
            event.target.value = null; 
        }

        function openTagEditModal(bookName) {
            bookNameToEditTags = bookName;
            const book = bookshelf.find(b => b.name === bookName);
            if (!book) return;

            tagEditModalTitle.textContent = book.name;
            renderTagPills();
            newTagInput.value = '';
            tagEditModal.style.display = 'flex';
            newTagInput.focus();
        }

        function renderTagPills() {
            currentTagsList.innerHTML = '';
            const book = bookshelf.find(b => b.name === bookNameToEditTags);
            if (!book || !book.tags || book.tags.length === 0) {
                 currentTagsList.textContent = '暂无标签';
                 return;
            }
            book.tags.forEach(tag => {
                const pill = document.createElement('span');
                pill.className = 'tag-pill';
                pill.textContent = tag;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-tag-btn';
                removeBtn.innerHTML = '&times;';
                removeBtn.dataset.tag = tag;
                removeBtn.title = `移除标签“${tag}”`;
                
                pill.appendChild(removeBtn);
                currentTagsList.appendChild(pill);
            });
        }
        
        function handleAddTag(event) {
            event.preventDefault();
            const book = bookshelf.find(b => b.name === bookNameToEditTags);
            const newTag = newTagInput.value.trim();
            if (book && newTag && !(book.tags || []).includes(newTag)) {
                if(!book.tags) book.tags = [];
                book.tags.push(newTag);
                book.tags.sort();
                saveBookshelf();
                renderTagPills();
            }
            newTagInput.value = '';
        }

        function handleRemoveTag(event) {
            if (event.target.classList.contains('remove-tag-btn')) {
                const book = bookshelf.find(b => b.name === bookNameToEditTags);
                const tagToRemove = event.target.dataset.tag;
                if (book && (book.tags || []).includes(tagToRemove)) {
                    book.tags = book.tags.filter(t => t !== tagToRemove);
                    saveBookshelf();
                    renderTagPills();
                }
            }
        }

        function closeTagModalAndRefresh() {
            tagEditModal.style.display = 'none';
            bookNameToEditTags = null;
            populateFilterDropdown();
            renderBookshelf();
        }
        
        function updateHeaderForState() { const isOriginal = activeSubView === 'original', hasBook = !!currentFileName; btnAiMenu.style.display = isOriginal && hasBook ? 'inline-block' : 'none'; btnAddToShelf.style.display = isOriginal && hasBook ? 'inline-block' : 'none'; btnCatalog.style.display = isOriginal && hasBook && chapters.length > 0 ? 'inline-block' : 'none'; btnBackToOriginal.style.display = !isOriginal ? 'inline-block' : 'none'; btnSearch.style.display = hasBook ? 'inline-block' : 'none'; if (isOriginal && hasBook) updateAddToShelfButton(); }

        // --- Search Functionality ---
        function clearHighlights() {
            allRenderedPages.forEach(page => {
                const highlights = page.querySelectorAll('span.search-highlight');
                if (highlights.length === 0) return;
                highlights.forEach(span => {
                    const parent = span.parentNode;
                    if (parent) {
                        parent.replaceChild(document.createTextNode(span.textContent), span);
                        parent.normalize();
                    }
                });
            });
        }
        function clearSearch() {
            if (searchResults.length > 0) {
                clearHighlights();
            }
            searchResults = [];
            currentSearchIndex = -1;
            searchBar.style.display = 'none';
            searchInput.value = '';
            updateSearchUI();
            updateDOMPages(); // Refresh view to ensure highlights are gone
        }
        function getCurrentChapterBoundaries() {
            if (chapters.length === 0) return null;
            const firstPOnPage = allRenderedPages[currentPage - 1]?.querySelector("p[data-original-index]");
            if (!firstPOnPage) return null;
            const pIndex = parseInt(firstPOnPage.dataset.originalIndex, 10);

            let currentChap = null;
            for (let i = chapters.length - 1; i >= 0; i--) {
                if (chapters[i].p_index <= pIndex) {
                    currentChap = chapters[i];
                    break;
                }
            }

            if (!currentChap) {
                const firstChapter = chapters[0];
                return pIndex < firstChapter.p_index ? { startPIndex: 0, endPIndex: firstChapter.p_index } : null;
            }

            const nextChap = chapters.find(c => c.chap_num === currentChap.chap_num + 1);
            const startPIndex = currentChap.p_index;
            const endPIndex = nextChap ? nextChap.p_index : originalParagraphs.length;

            return { startPIndex, endPIndex };
        }
        function executeSearch(scope = 'all') {
            const keyword = searchInput.value.trim();
            clearHighlights();
            searchResults = [];
            currentSearchIndex = -1;

            if (!keyword) {
                updateSearchUI();
                return;
            }

            let pagesToSearch = [];
            if (scope === 'chapter') {
                const boundaries = getCurrentChapterBoundaries();
                if (!boundaries) {
                    alert("无法确定当前章节范围，请在章节正文内搜索。");
                    updateSearchUI();
                    return;
                }
                pagesToSearch = allRenderedPages.filter(page => {
                    const pageParas = page.querySelectorAll('p[data-original-index]');
                    if (pageParas.length === 0) return false;
                    const firstPIndex = parseInt(pageParas[0].dataset.originalIndex, 10);
                    const lastPIndex = parseInt(pageParas[pageParas.length - 1].dataset.originalIndex, 10);
                    return firstPIndex < boundaries.endPIndex && lastPIndex >= boundaries.startPIndex;
                });
            } else { // 'all'
                pagesToSearch = allRenderedPages;
            }

            const keywordRegex = new RegExp(escapeHtml(keyword).replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            
            function highlightInNode(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const matches = node.nodeValue.match(keywordRegex);
                    if (matches) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = node.nodeValue.replace(keywordRegex, `<span class="search-highlight">$&</span>`);
                        const fragment = document.createDocumentFragment();
                        while (tempDiv.firstChild) {
                            const child = tempDiv.firstChild;
                            fragment.appendChild(child);
                            if (child.nodeName === 'SPAN' && child.classList.contains('search-highlight')) {
                                searchResults.push(child);
                            }
                        }
                        node.parentNode.replaceChild(fragment, node);
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('search-highlight') && node.childNodes && !/^(script|style)$/i.test(node.tagName)) {
                    for (let i = node.childNodes.length - 1; i >= 0; i--) {
                        highlightInNode(node.childNodes[i]);
                    }
                }
            }

            pagesToSearch.forEach(page => highlightInNode(page));
            
            updateDOMPages(); // Refresh view to show highlights

            if (searchResults.length > 0) {
                currentSearchIndex = 0;
                navigateToSearchResult('current');
            }
            updateSearchUI();
        }
        function navigateToSearchResult(direction) {
            if (searchResults.length === 0) return;

            if (currentSearchIndex > -1 && searchResults[currentSearchIndex]) {
                searchResults[currentSearchIndex].classList.remove('active');
            }

            if (direction === 'next') {
                currentSearchIndex = (currentSearchIndex + 1) % searchResults.length;
            } else if (direction === 'prev') {
                currentSearchIndex = (currentSearchIndex - 1 + searchResults.length) % searchResults.length;
            }

            const currentMatch = searchResults[currentSearchIndex];
            if (!currentMatch) return;
            
            currentMatch.classList.add('active');
            
            const pageElement = currentMatch.closest('.page');
            if (!pageElement) return;

            const targetPage = allRenderedPages.indexOf(pageElement) + 1;
            
            if (targetPage > 0 && targetPage !== currentPage) {
                jumpToPage(targetPage);
                 setTimeout(() => {
                    const newMatch = searchResults[currentSearchIndex];
                    if (newMatch) {
                         newMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                 }, 350);
            } else {
                 currentMatch.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            updateSearchUI();
        }
        function updateSearchUI() {
            if (searchResults.length > 0) {
                searchResultsInfo.textContent = `${currentSearchIndex + 1} / ${searchResults.length}`;
            } else {
                searchResultsInfo.textContent = searchInput.value ? '0 / 0' : '';
            }
            btnSearchPrev.disabled = searchResults.length <= 1;
            btnSearchNext.disabled = searchResults.length <= 1;
        }

        // --- Settings, AI, and other functions ---
        // MODIFICATION START: Update IndexedDB logic
        const storageDB = {
            db: null,
            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open("NovelReaderDatabase", 2); // Version 2
                    request.onupgradeneeded = event => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains("assets")) {
                            db.createObjectStore("assets", { keyPath: "id" });
                        }
                        if (!db.objectStoreNames.contains("books")) { // New store for books
                            db.createObjectStore("books", { keyPath: "id" });
                        }
                    };
                    request.onsuccess = event => {
                        this.db = event.target.result;
                        resolve();
                    };
                    request.onerror = event => reject("IndexedDB error: " + event.target.errorCode);
                });
            },
            _getStore(name, mode) {
                 return this.db.transaction([name], mode).objectStore(name);
            },
            saveAsset(asset) { return new Promise((resolve, reject) => { const req = this._getStore('assets', 'readwrite').put(asset); req.onsuccess = resolve; req.onerror = e => reject("Failed to save asset: " + e.target.error); }); },
            loadAsset(id) { return new Promise((resolve, reject) => { const req = this._getStore('assets', 'readonly').get(id); req.onsuccess = () => resolve(req.result); req.onerror = e => reject("Failed to load asset: " + e.target.error); }); },
            deleteAsset(id) { return new Promise((resolve, reject) => { const req = this._getStore('assets', 'readwrite').delete(id); req.onsuccess = resolve; req.onerror = e => reject("Failed to delete asset: " + e.target.error); }); },
            saveBook(book) { return new Promise((resolve, reject) => { const req = this._getStore('books', 'readwrite').put(book); req.onsuccess = resolve; req.onerror = e => reject("Failed to save book: " + e.target.error); }); },
            loadBook(id) { return new Promise((resolve, reject) => { const req = this._getStore('books', 'readonly').get(id); req.onsuccess = () => resolve(req.result); req.onerror = e => reject("Failed to load book: " + e.target.error); }); },
            deleteBook(id) { return new Promise((resolve, reject) => { const req = this._getStore('books', 'readwrite').delete(id); req.onsuccess = resolve; req.onerror = e => reject("Failed to delete book: " + e.target.error); }); },
            clearBooks() { return new Promise((resolve, reject) => { const req = this._getStore('books', 'readwrite').clear(); req.onsuccess = resolve; req.onerror = e => reject("Failed to clear books: " + e.target.error); }); },
        };
        // MODIFICATION END

        function saveSettings() { localStorage.setItem('novelReaderSettings', JSON.stringify(settings)); }
        function loadSettings() { const saved = localStorage.getItem('novelReaderSettings'); if (saved) { settings = { ...settings, ...JSON.parse(saved) }; } }
        function rgbToHex(rgb) { try { let [r, g, b] = rgb.match(/\d+/g).map(Number); return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); } catch (e) { return '#000000'; } }
        
        function applySettings() {
            contentWrapper.style.cursor = settings.enableClickPage ? 'pointer' : 'default';
            toggleClickPage.checked = settings.enableClickPage;
            toggleSwipePage.checked = settings.enableSwipePage;
            toggleHoverHighlight.checked = settings.enableHoverHighlight;
            toggleDialogueHighlight.checked = settings.enableDialogueHighlight;
            document.body.classList.toggle('hover-highlight-disabled', !settings.enableHoverHighlight);
            document.body.classList.toggle('dialogue-highlight-disabled', !settings.enableDialogueHighlight);
            
            document.body.style.removeProperty('--text-color');
            document.body.style.removeProperty('--bg-color');
            document.body.style.removeProperty('--dialogue-color');

            if (settings.customTextColor) document.body.style.setProperty('--text-color', settings.customTextColor);
            if (settings.customBgColor) document.body.style.setProperty('--bg-color', settings.customBgColor);
            if (settings.dialogueCustomColor) document.body.style.setProperty('--dialogue-color', settings.dialogueCustomColor);
            
            let currentTextColor = getComputedStyle(document.body).getPropertyValue('--text-color').trim();
            textColorPicker.value = currentTextColor.startsWith('rgb') ? rgbToHex(currentTextColor) : currentTextColor;

            let currentBgColor = getComputedStyle(document.body).getPropertyValue('--bg-color').trim();
            bgColorPicker.value = currentBgColor.startsWith('rgb') ? rgbToHex(currentBgColor) : currentBgColor;

            let currentDialogueColor = getComputedStyle(document.body).getPropertyValue('--dialogue-color').trim();
            dialogueColorPicker.value = currentDialogueColor.startsWith('rgb') ? rgbToHex(currentDialogueColor) : currentDialogueColor;

            document.documentElement.style.setProperty('--font-size', `${settings.fontSize}px`);
            document.documentElement.style.setProperty('--letter-spacing', `${settings.letterSpacing}px`);
            document.documentElement.style.setProperty('--line-height', settings.lineHeight);
            document.documentElement.style.setProperty('--paragraph-spacing', `${settings.paragraphSpacing}em`);

            fontSizeSlider.value = settings.fontSize;
            fontSizeValue.textContent = `${settings.fontSize}px`;
            letterSpacingSlider.value = settings.letterSpacing;
            letterSpacingValue.textContent = `${settings.letterSpacing.toFixed(1)}px`;
            lineHeightSlider.value = settings.lineHeight;
            lineHeightValue.textContent = settings.lineHeight.toFixed(1);
            paragraphSpacingSlider.value = settings.paragraphSpacing;
            paragraphSpacingValue.textContent = `${settings.paragraphSpacing.toFixed(1)}em`;
        }

        function handleSettingsChange() {
            settings.enableClickPage = toggleClickPage.checked;
            settings.enableSwipePage = toggleSwipePage.checked;
            settings.enableHoverHighlight = toggleHoverHighlight.checked;
            settings.enableDialogueHighlight = toggleDialogueHighlight.checked;
            saveSettings();
            applySettings();
        }
        function rePaginateBook(silent = false) {
            if (currentFileName && readerView.style.display !== 'none') {
                const currentPageParas = allRenderedPages[currentPage - 1]?.querySelectorAll('p[data-original-index]');
                const startPIndex = currentPageParas && currentPageParas.length > 0 ? parseInt(currentPageParas[0].dataset.originalIndex, 10) : 0;
                
                const options = { isRepagination: true };
                if (silent) {
                    paginate().then(() => {
                        let targetPage = 1;
                        if(startPIndex > 0) {
                            for (let i = 0; i < allRenderedPages.length; i++) {
                                const firstParaOnNewPage = allRenderedPages[i].querySelector('p[data-original-index]');
                                if(firstParaOnNewPage && parseInt(firstParaOnNewPage.dataset.originalIndex, 10) >= startPIndex) {
                                    targetPage = i + 1;
                                    break;
                                }
                            }
                        }
                        currentPage = targetPage;
                        updateDOMPages();
                        updateUI();
                    });
                } else {
                    loadBook(currentFileName, currentFileContent, options).then(() => {
                        let targetPage = 1;
                        if(startPIndex > 0) {
                            for (let i = 0; i < allRenderedPages.length; i++) {
                                const firstParaOnNewPage = allRenderedPages[i].querySelector('p[data-original-index]');
                                if(firstParaOnNewPage && parseInt(firstParaOnNewPage.dataset.originalIndex, 10) >= startPIndex) {
                                    targetPage = i + 1;
                                    break;
                                }
                            }
                        }
                        if (currentPage !== targetPage) {
                            jumpToPage(targetPage);
                        }
                    });
                }
            }
        }
        
        function applyCustomFont(e,t){removeCustomFont();const n=URL.createObjectURL(e);currentCustomFontUrl=n;const o=document.createElement("style");o.id="custom-font-stylesheet",o.textContent=`@font-face { font-family: 'user-custom-font'; src: url('${n}'); }`,document.head.appendChild(o);document.body.style.fontFamily=`'user-custom-font', ${getComputedStyle(document.body).fontFamily}`,customFontStatus.textContent=`当前字体: ${t}`}
        function removeCustomFont(){const e=document.getElementById("custom-font-stylesheet");e&&e.remove(),currentCustomFontUrl&&(URL.revokeObjectURL(currentCustomFontUrl),currentCustomFontUrl=null),document.body.style.fontFamily="",customFontStatus.textContent="未设置",fontFileInput.value=""}
        async function handleFontFileChange(e){const t=e.target.files[0];if(!t)return;try{await storageDB.saveAsset({id:"custom-font",name:t.name,data:t});applyCustomFont(t,t.name);fontSettingsChanged = true;}catch(e){console.error("Error handling font file:",e),alert("保存或应用字体时出错。")}}
        async function handleClearFont(){try{await storageDB.deleteAsset("custom-font");removeCustomFont();fontSettingsChanged = true;}catch(e){console.error("Error clearing font:",e),alert("清除字体时出错。")}}
        function applyCustomBgImage(e){removeCustomBgImage(!1);currentBgImageUrl=URL.createObjectURL(e);document.body.style.backgroundImage=`url(${currentBgImageUrl})`;settings.customBgColor||document.body.classList.add("custom-background-active")}
        function removeCustomBgImage(e=!0){currentBgImageUrl&&(URL.revokeObjectURL(currentBgImageUrl),currentBgImageUrl=null);document.body.style.backgroundImage="";document.body.classList.remove("custom-background-active");bgImageInput.value="";e&&storageDB.deleteAsset("custom-bg-image").catch(e=>console.error("Failed to delete bg image",e))}
        async function handleBgImageChange(e){const t=e.target.files[0];if(!t)return;try{await storageDB.saveAsset({id:"custom-bg-image",data:t});applyCustomBgImage(t)}catch(e){console.error("Error handling bg image:",e),alert("保存或应用背景图时出错。")}}
        async function handleClearBgImage(){try{await storageDB.deleteAsset("custom-bg-image");removeCustomBgImage()}catch(e){console.error("Error clearing bg image:",e),alert("清除背景图时出错。")}}
        async function loadAndApplyAssetsFromDB(){try{const e=await storageDB.loadAsset("custom-font");e&&applyCustomFont(e.data,e.name);const t=await storageDB.loadAsset("custom-bg-image");t&&applyCustomBgImage(t.data)}catch(e){console.error("Failed to load assets from DB:",e)}}

        function saveAiSettings() { aiSettings.apiUrl = aiApiUrlInput.value.trim(); aiSettings.apiKey = aiApiKeyInput.value.trim(); aiSettings.modelName = aiModelNameInput.value.trim(); aiSettings.summaryLength = parseInt(aiSummaryLengthInput.value, 10) || 100; aiSettings.summaryPrompt = aiSummaryPromptInput.value.trim(); aiSettings.translationPrompt = aiTranslationPromptInput.value.trim(); aiSettings.sequelPrompt = aiSequelPromptInput.value.trim(); localStorage.setItem("novelReaderAiSettings", JSON.stringify(aiSettings)); alert("AI 设置已保存。"); aiSettingsModal.style.display = "none"; }
        function loadAiSettings() { const e = localStorage.getItem("novelReaderAiSettings"); if (e) { aiSettings = { ...aiSettings, ...JSON.parse(e) }; } aiApiUrlInput.value = aiSettings.apiUrl || ""; aiApiKeyInput.value = aiSettings.apiKey || ""; aiModelNameInput.value = aiSettings.modelName || ""; aiSummaryLengthInput.value = aiSettings.summaryLength || 100; aiSummaryPromptInput.value = aiSettings.summaryPrompt || ""; aiTranslationPromptInput.value = aiSettings.translationPrompt || ""; aiSequelPromptInput.value = aiSettings.sequelPrompt || ""; }
        
        async function handleFactoryReset() { const confirmation = confirm("【高风险操作】\n\n您确定要恢复所有默认设置吗？\n\n这将导致：\n- 所有阅读器和AI设置被重置\n- 自定义字体和背景图被清除\n- 整个书架被清空\n- 所有书籍的阅读进度、总结、续写和翻译历史将永久丢失！\n\n此操作无法撤销！"); if (confirmation) { try { for (let i = localStorage.length - 1; i >= 0; i--) { const key = localStorage.key(i); if (key.startsWith('novelReader')) { localStorage.removeItem(key); } } await storageDB.deleteAsset("custom-font"); await storageDB.deleteAsset("custom-bg-image"); await storageDB.clearBooks(); alert("所有设置和数据已清除。应用即将刷新。"); location.reload(); } catch(e) { alert("清除数据时发生错误: " + e.message); } } }

        function getTextForPage(e){return e<1||e>allRenderedPages.length?"":allRenderedPages[e-1].innerText}
        function getTextForPageRange(e,t){let n=[];for(let o=e;o<=t;o++)n.push(getTextForPage(o));return n.join("\n\n")}
        function getTextForChapter(chapNum) { if (!chapters[chapNum - 1]) return null; const chap = chapters[chapNum - 1]; const nextChap = chapters[chapNum]; const startIdx = chap.p_index; const endIdx = nextChap ? nextChap.p_index : originalParagraphs.length; return originalParagraphs.slice(startIdx, endIdx).map(p => p.textContent).join('\n'); }
        function getTextForCurrentChapter() { if (chapters.length === 0) { alert("未能解析到章节目录。"); return null; } const p = allRenderedPages[currentPage - 1]?.querySelector("p[data-original-index]"); if (!p) { alert("无法定位当前页的段落信息。"); return null; } const pIndex = parseInt(p.dataset.originalIndex, 10); let currentChap = null; for (let i = chapters.length - 1; i >= 0; i--) { if (chapters[i].p_index <= pIndex) { currentChap = chapters[i]; break; } } if (!currentChap) { alert("无法定位当前章节。"); return null; } return { text: getTextForChapter(currentChap.chap_num), title: currentChap.title }; }
        
        async function getSummary(text, rangeDesc) { await handleAddToShelf(); if (!text || text.trim().length === 0) return alert("没有内容可以总结。"); summaryChoiceModal.style.display = "none"; summaryDisplayModal.style.display = "flex"; summaryContent.textContent = "正在生成总结..."; btnSaveSummary.style.display = 'none'; const len = aiSettings.summaryLength || 100; const prompt = `${aiSettings.summaryPrompt.trim()||`请将以下内容总结成一段文字，最多${len}字。`}\n\n${text}`; try { const res = await fetch(aiSettings.apiUrl, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${aiSettings.apiKey}` }, body: JSON.stringify({ model: aiSettings.modelName, messages: [{ role: "user", content: prompt }], stream: false }) }); if (!res.ok) { const errText = await res.text(); throw new Error(`API 请求失败: ${res.status} ${res.statusText}\n${errText}`); } const data = await res.json(); const summary = data.choices[0]?.message?.content; if (summary) { summaryContent.textContent = summary.trim(); tempSummaryHolder = { text: summary.trim(), range: rangeDesc }; btnSaveSummary.style.display = 'block'; } else { throw new Error("API 返回数据格式不正确或内容为空。"); } } catch (err) { console.error("总结失败:", err); summaryContent.textContent = `生成总结时出错: ${err.message}`; } }
        function saveCurrentSummary() { if (!tempSummaryHolder.text) return; if (currentBookData.summaries.some(s => s.text === tempSummaryHolder.text)) { alert("该总结已存在。"); return; } currentBookData.summaries.push({ ...tempSummaryHolder, timestamp: Date.now() }); saveBookData(); alert("总结已保存。"); btnSaveSummary.style.display = 'none'; tempSummaryHolder = {}; }
        
        async function getTranslation(text, rangeDesc) { await handleAddToShelf(); if(!text||0===text.trim().length)return void alert("没有内容可以翻译。");translationChoiceModal.style.display="none",appLoader.classList.remove("hidden"),appLoader.querySelector("span").textContent="正在翻译，请稍候...";const t="你是一位小说翻译大师...请直接翻译。",n=`${aiSettings.translationPrompt.trim()||t}\n\n---\n\n${text}`;try{const t=await fetch(aiSettings.apiUrl,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${aiSettings.apiKey}`},body:JSON.stringify({model:aiSettings.modelName,messages:[{role:"user",content:n}],stream:!1})});if(!t.ok){const e=await t.text();throw new Error(`API 请求失败: ${t.status} ${t.statusText}\n${e}`)}const o=await t.json(),r=o.choices[0]?.message?.content;if(r){const translatedContent=r.trim();currentBookData.translations.push({content:translatedContent,sourceRange:rangeDesc,timestamp:Date.now()});saveBookData();originalContentForSubView={name:currentFileName,content:currentFileContent};activeSubView='translation';await loadBook(`【译】${originalContentForSubView.name}`,translatedContent);}else throw new Error("API 返回数据格式不正确或内容为空。")}catch(e){console.error("翻译失败:",e),alert(`生成译文时出错: ${e.message}`)}finally{appLoader.classList.add("hidden"),appLoader.querySelector("span").textContent="正在加载..."}}

        async function getSequel(text, rangeDesc) { await handleAddToShelf(); if (!text || text.trim().length === 0) return alert("没有内容可以续写。"); const selectedSummaries = Array.from(sequelSummaryContextList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value).join('\n\n'); const context = selectedSummaries ? `请参考以下故事背景/摘要：\n${selectedSummaries}\n\n---\n\n` : ''; sequelChoiceModal.style.display = "none"; appLoader.classList.remove('hidden'); appLoader.querySelector('span').textContent = "AI 正在创作续写..."; const defaultPrompt = '你是一位才华横溢的小说家...请接着写下去。'; const prompt = `${aiSettings.sequelPrompt.trim() || defaultPrompt}\n\n${context}请接着以下内容写：\n\n${text}`; try { const res = await fetch(aiSettings.apiUrl, { method: "POST", headers: { "Content-Type": "application/json", Authorization: `Bearer ${aiSettings.apiKey}` }, body: JSON.stringify({ model: aiSettings.modelName, messages: [{ role: "user", content: prompt }], stream: false }) }); if (!res.ok) { const errText = await res.text(); throw new Error(`API 请求失败: ${res.status} ${res.statusText}\n${errText}`); } const data = await res.json(); const sequelContent = data.choices[0]?.message?.content; if (sequelContent) { currentBookData.sequels.push({ content: sequelContent.trim(), sourceRange: rangeDesc, timestamp: Date.now() }); saveBookData(); originalContentForSubView = { name: currentFileName, content: currentFileContent }; activeSubView = 'sequel'; await loadBook(`【续】${originalContentForSubView.name}`, sequelContent.trim()); } else { throw new Error("API 返回数据格式不正确或内容为空。"); } } catch (err) { console.error("续写失败:", err); alert(`生成续写时出错: ${err.message}`); } finally { appLoader.classList.add("hidden"); appLoader.querySelector("span").textContent = "正在加载..."; } }

        function renderHistoryList(listElement, historyData, type) { listElement.innerHTML = ''; const noHistoryMsg = { summary: '没有已保存的总结。', sequel: '没有已保存的续写。', translation: '没有已保存的翻译。' }; if (historyData.length === 0) { listElement.innerHTML = `<li>${noHistoryMsg[type]}</li>`; return; } historyData.sort((a, b) => b.timestamp - a.timestamp).forEach(item => { const li = document.createElement('li'); const title = type === 'summary' ? item.range : `于 <strong>${escapeHtml(item.sourceRange)}</strong>`; const contentPreview = escapeHtml(item.text || item.content).substring(0, 100); li.innerHTML = `<span>${title}</span> <div class="modal-list-actions"> ${type !== 'summary' ? `<button class="action-btn view-btn" data-timestamp="${item.timestamp}">查看</button>` : ''} <button class="action-btn delete-btn" data-timestamp="${item.timestamp}">删除</button> </div> <div class="history-item-text">${contentPreview}...</div>`; listElement.appendChild(li); }); }
        
        const historyListViewOrDeleteHandler = (e, type, listElement, modalElement) => { const ts = parseInt(e.target.dataset.timestamp, 10); if (e.target.classList.contains('delete-btn')) { currentBookData[type + 's'] = currentBookData[type + 's'].filter(s => s.timestamp !== ts); saveBookData(); renderHistoryList(listElement, currentBookData[type + 's'], type); } else if (e.target.classList.contains('view-btn')) { const item = currentBookData[type + 's'].find(s => s.timestamp === ts); if (item) { originalContentForSubView = { name: currentFileName, content: currentFileContent }; activeSubView = type; modalElement.style.display = 'none'; const prefix = { sequel: '【续】', translation: '【译】' }[type]; loadBook(`${prefix}${originalContentForSubView.name}`, item.content); } } };
        summaryHistoryList.addEventListener('click', e => { if (e.target.classList.contains('delete-btn')) { const ts = parseInt(e.target.dataset.timestamp, 10); currentBookData.summaries = currentBookData.summaries.filter(s => s.timestamp !== ts); saveBookData(); renderHistoryList(summaryHistoryList, currentBookData.summaries, 'summary'); } });
        sequelHistoryList.addEventListener('click', e => historyListViewOrDeleteHandler(e, 'sequel', sequelHistoryList, sequelHistoryModal));
        translationHistoryList.addEventListener('click', e => historyListViewOrDeleteHandler(e, 'translation', translationHistoryList, translationHistoryModal));

        // --- Event Listeners & Interaction Handling ---
        function getEventX(e) { return e.type.startsWith('touch') ? e.changedTouches[0].clientX : e.clientX; }
        function dragStart(e) { if (!settings.enableSwipePage || totalPages <= 0 || isTransitioning) return; isDragging = true; dragStartX = getEventX(e); contentInner.classList.add('is-dragging'); }
        function dragMove(e) { if (!isDragging) return; dragDelta = getEventX(e) - dragStartX; contentInner.style.transform = `translateX(${currentTranslate + dragDelta}px)`; }
        function dragEnd() { if (!isDragging) return; isDragging = false; contentInner.classList.remove('is-dragging'); const threshold = viewportWidth * 0.3; if (Math.abs(dragDelta) > 10) ignoreNextClick = true; if (dragDelta < -threshold) jumpToPage(currentPage + 1); else if (dragDelta > threshold) jumpToPage(currentPage - 1); else contentInner.style.transform = `translateX(${currentTranslate}px)`; dragDelta = 0; }
        
        function getEventY(e) { return e.type.startsWith('touch') ? e.touches[0].pageY : e.pageY; }
        function shelfDragStart(e) {
            if (e.button !== 0 && e.type.startsWith('mouse')) return;
            if (e.offsetX > bookshelfGrid.clientWidth) return;
            isShelfDragging = true;
            shelfStartY = getEventY(e);
            shelfScrollTopStart = bookshelfGrid.scrollTop;
            bookshelfGrid.classList.add('is-dragging');
            ignoreNextClick = false;
        }
        function shelfDragMove(e) {
            if (!isShelfDragging) return;
            e.preventDefault();
            const currentY = getEventY(e);
            const deltaY = currentY - shelfStartY;
            bookshelfGrid.scrollTop = shelfScrollTopStart - deltaY;
            if (Math.abs(deltaY) > 10) {
                ignoreNextClick = true;
            }
        }
        function shelfDragEnd() {
            if (!isShelfDragging) return;
            isShelfDragging = false;
            bookshelfGrid.classList.remove('is-dragging');
        }

        function toggleImmersiveMode() {
            if (!currentFileName) return;

            const firstPOnPage = allRenderedPages[currentPage - 1]?.querySelector("p[data-original-index]");
            const pIndexToRestore = firstPOnPage ? parseInt(firstPOnPage.dataset.originalIndex, 10) : 0;

            isInImmersiveMode = !isInImmersiveMode;
            readerView.classList.toggle('immersive-active', isInImmersiveMode);

            setTimeout(async () => {
                await paginate();

                let newTargetPage = 1;
                for (let i = 0; i < allRenderedPages.length; i++) {
                    const firstPOnNewPage = allRenderedPages[i].querySelector('p[data-original-index]');
                    if (firstPOnNewPage && parseInt(firstPOnNewPage.dataset.originalIndex, 10) >= pIndexToRestore) {
                        newTargetPage = i + 1;
                        break;
                    }
                }
                
                currentPage = newTargetPage;
                updateDOMPages();
                updateUI();
                saveProgress(currentFileName, currentPage);
            }, 350);
        }

        function setupModal(modal, openBtn, onOpen, onClose) {
            const closeBtn = modal.querySelector('.close-button');
            const closeHandler = () => {
                modal.style.display = 'none';
                if (onClose) onClose();
            }
            if (openBtn) {
                openBtn.addEventListener('click', () => {
                    if (onOpen) onOpen();
                    modal.style.display = 'flex';
                });
            }
            if(closeBtn) closeBtn.addEventListener('click', closeHandler);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeHandler();
            });
        }
        
        function applyInitialTheme() { const savedTheme = localStorage.getItem('novelReaderTheme') || 'default'; switchTheme(savedTheme, true); themeSelector.value = savedTheme; }
        function switchTheme(themeName, isInitial = false) { document.body.classList.remove("theme-dark", "theme-green", "theme-blue", "theme-gray"); if (themeName !== 'default') document.body.classList.add(themeName); localStorage.setItem('novelReaderTheme', themeName); if (!isInitial) { fontSettingsChanged = true; } applySettings(); }
        function saveProgress(fileName, page) { if (fileName) localStorage.setItem(`novelReaderProgress_${fileName}`, page); }
        function loadProgress(fileName) { return fileName ? parseInt(localStorage.getItem(`novelReaderProgress_${fileName}`), 10) : null; }

        fileInput.addEventListener('change', loadBookFromFile);
        themeSelector.addEventListener('change', (e) => switchTheme(e.target.value));
        btnBackToShelf.addEventListener('click', showBookshelfView);
        catalogList.addEventListener('click', handleCatalogClick); btnAddToShelf.addEventListener('click', handleAddToShelf);
        btnBackToOriginal.addEventListener('click', () => { if (activeSubView !== 'original') { activeSubView = 'original'; loadBook(originalContentForSubView.name, originalContentForSubView.content); } });
        [toggleClickPage, toggleSwipePage, toggleHoverHighlight, toggleDialogueHighlight].forEach(el => el.addEventListener('change', handleSettingsChange));
        
        importFilesInput.addEventListener('change', handleFileImport);
        importFolderInput.addEventListener('change', handleFileImport);
        bookshelfFilter.addEventListener('change', (e) => {
            activeFilterTag = e.target.value || null;
            renderBookshelf();
        });
        addTagForm.addEventListener('submit', handleAddTag);
        currentTagsList.addEventListener('click', handleRemoveTag);
        btnCloseTagModal.addEventListener('click', closeTagModalAndRefresh);

        dialogueColorPicker.addEventListener('input', e => { settings.dialogueCustomColor = e.target.value; saveSettings(); applySettings(); });
        btnResetDialogueColor.addEventListener('click', () => { settings.dialogueCustomColor = null; saveSettings(); applySettings(); });
        textColorPicker.addEventListener('input', e => { settings.customTextColor = e.target.value; saveSettings(); applySettings(); });
        btnResetTextColor.addEventListener('click', () => { settings.customTextColor = null; saveSettings(); applySettings(); });
        bgColorPicker.addEventListener('input', e => { settings.customBgColor = e.target.value; document.body.classList.remove("custom-background-active"); saveSettings(); applySettings(); });
        btnResetBgColor.addEventListener('click', () => { settings.customBgColor = null; if(currentBgImageUrl) document.body.classList.add("custom-background-active"); saveSettings(); applySettings(); });
        bgImageInput.addEventListener('change', handleBgImageChange);
        btnClearBgImage.addEventListener('click', handleClearBgImage);
        btnImmersiveMode.addEventListener('click', toggleImmersiveMode);

        btnSaveAiSettings.addEventListener('click', saveAiSettings); btnSaveSummary.addEventListener('click', saveCurrentSummary);
        fontFileInput.addEventListener('change', handleFontFileChange); btnClearFont.addEventListener('click', handleClearFont);
        btnFactoryReset.addEventListener('click', handleFactoryReset);
        
        function setupFontControl(slider, valueDisplay, settingKey, unit, isFloat) {
            slider.addEventListener('input', () => {
                let value = isFloat ? parseFloat(slider.value) : parseInt(slider.value, 10);
                settings[settingKey] = value;
                valueDisplay.textContent = `${value.toFixed(isFloat ? 1 : 0)}${unit}`;
                applySettings();
            });
            slider.addEventListener('change', () => {
                saveSettings();
                fontSettingsChanged = true;
            });
        }
        function setupFontReset(button, settingKey, defaultValue) {
            button.addEventListener('click', () => {
                if(settings[settingKey] !== defaultValue){
                    settings[settingKey] = defaultValue;
                    saveSettings();
                    applySettings();
                    fontSettingsChanged = true;
                }
            });
        }

        setupFontControl(fontSizeSlider, fontSizeValue, 'fontSize', 'px', false);
        setupFontControl(letterSpacingSlider, letterSpacingValue, 'letterSpacing', 'px', true);
        setupFontControl(lineHeightSlider, lineHeightValue, 'lineHeight', '', true);
        setupFontControl(paragraphSpacingSlider, paragraphSpacingValue, 'paragraphSpacing', 'em', true);
        setupFontReset(resetFontSize, 'fontSize', defaultFontSettings.fontSize);
        setupFontReset(resetLetterSpacing, 'letterSpacing', defaultFontSettings.letterSpacing);
        setupFontReset(resetLineHeight, 'lineHeight', defaultFontSettings.lineHeight);
        setupFontReset(resetParagraphSpacing, 'paragraphSpacing', defaultFontSettings.paragraphSpacing);

        btnSearch.addEventListener('click', () => {
            searchBar.style.display = searchBar.style.display === 'none' ? 'flex' : 'none';
            if (searchBar.style.display === 'none') {
                clearSearch();
            } else {
                searchInput.focus();
            }
        });
        btnCloseSearch.addEventListener('click', clearSearch);
        searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') executeSearch('all'); });
        btnSearchAll.addEventListener('click', () => executeSearch('all'));
        btnSearchChapter.addEventListener('click', () => executeSearch('chapter'));
        btnSearchNext.addEventListener('click', () => navigateToSearchResult('next'));
        btnSearchPrev.addEventListener('click', () => navigateToSearchResult('prev'));

        function checkAiConfigAndShow(modalToShow, onOpen) {
            if (!aiSettings.apiUrl || !aiSettings.apiKey || !aiSettings.modelName) {
                alert("AI 功能需要配置后才能使用，请点击“设置”按钮进行配置。");
                return;
            }
            aiMenuModal.style.display = 'none';
            if (onOpen) onOpen();
            modalToShow.style.display = 'flex';
        }
        
        btnSummary.addEventListener('click', () => checkAiConfigAndShow(summaryChoiceModal));
        btnTranslate.addEventListener('click', () => checkAiConfigAndShow(translationChoiceModal));
        btnSequel.addEventListener('click', () => checkAiConfigAndShow(sequelChoiceModal, () => {
            sequelSummaryContextList.innerHTML = ''; if (currentBookData.summaries.length === 0) { sequelSummaryContextList.innerHTML = '<li style="cursor:default;">无可用总结作为参考。</li>'; return; }
            currentBookData.summaries.forEach(s => { const li = document.createElement('li'); li.style.cursor = 'default'; li.innerHTML = `<label style="display: flex; align-items: start; width:100%;"><input type="checkbox" value="${escapeHtml(s.text)}" style="margin-top: 5px; margin-right: 8px;"><div><strong>${escapeHtml(s.range)}</strong><div style="font-size:0.9em; white-space:normal; opacity:0.8;">${escapeHtml(s.text.substring(0,80))}...</div></div></label>`; sequelSummaryContextList.appendChild(li); });
        }));
        btnSummaryHistory.addEventListener('click', () => { aiMenuModal.style.display = 'none'; renderHistoryList(summaryHistoryList, currentBookData.summaries, 'summary'); summaryHistoryModal.style.display = 'flex'; });
        btnSequelHistory.addEventListener('click', () => { aiMenuModal.style.display = 'none'; renderHistoryList(sequelHistoryList, currentBookData.sequels, 'sequel'); sequelHistoryModal.style.display = 'flex'; });
        btnTranslationHistory.addEventListener('click', () => { aiMenuModal.style.display = 'none'; renderHistoryList(translationHistoryList, currentBookData.translations, 'translation'); translationHistoryModal.style.display = 'flex'; });
        
        const handleRangeAction = async (actionType, promptMsg, defaultRange) => { const rangeStr = prompt(promptMsg, defaultRange); if (!rangeStr) return; const parts = rangeStr.trim().split(/[-\s,]+/); if (parts.length !== 2) { alert('输入格式不正确。'); return; } const [startPage, endPage] = parts.map(p => parseInt(p, 10)); if (isNaN(startPage) || isNaN(endPage) || startPage < 1 || endPage > totalPages || startPage > endPage) { alert('无效的页码范围。'); return; } const text = getTextForPageRange(startPage, endPage); if (text) { const rangeDesc = `第 ${startPage}-${endPage} 页`; if (actionType === 'summarize') await getSummary(text, rangeDesc); else if (actionType === 'translate') await getTranslation(text, rangeDesc); } };
        btnSummarizePage.addEventListener('click', () => getSummary(getTextForPage(currentPage), `第 ${currentPage} 页`));
        btnSummarizeChapter.addEventListener('click', () => { const chap = getTextForCurrentChapter(); if(chap) getSummary(chap.text, chap.title); });
        btnSummarizeRange.addEventListener('click', () => handleRangeAction('summarize', `请输入总结的起止页码...`, `${currentPage}-${Math.min(currentPage + 4, totalPages)}`));
        btnTranslatePage.addEventListener('click', () => getTranslation(getTextForPage(currentPage), `第 ${currentPage} 页`));
        btnTranslateChapter.addEventListener('click', () => { const chap = getTextForCurrentChapter(); if(chap) getTranslation(chap.text, chap.title); });
        btnTranslateRange.addEventListener('click', () => handleRangeAction('translate', `请输入翻译的起止页码...`, `${currentPage}-${Math.min(currentPage + 4, totalPages)}`));
        sequelRangeType.addEventListener('change', (e) => { const isPage = e.target.value === 'page'; sequelPageRangeSelector.style.display = isPage ? 'flex' : 'none'; sequelChapterRangeSelector.style.display = isPage ? 'none' : 'flex'; });
        btnGenerateSequel.addEventListener('click', () => { const type = sequelRangeType.value; let text, rangeDesc; if (type === 'page') { const rangeStr = sequelPageRangeInput.value; if (!rangeStr) return alert('请输入页码范围'); const parts = rangeStr.trim().split(/[-\s,]+/); if (parts.length !== 2) { alert('页码格式不正确。'); return; } const [start, end] = parts.map(p => parseInt(p, 10)); if (isNaN(start) || isNaN(end) || start < 1 || end > totalPages || start > end) { alert('无效的页码范围。'); return; } text = getTextForPageRange(start, end); rangeDesc = `第 ${start}-${end} 页`; } else { const rangeStr = sequelChapterRangeInput.value; if (!rangeStr) return alert('请输入章节范围'); const parts = rangeStr.trim().split(/[-\s,]+/); if (parts.length > 2) { alert('章节格式不正确。'); return; } const start = parseInt(parts[0], 10); const end = parts.length === 2 ? parseInt(parts[1], 10) : start; if (isNaN(start) || isNaN(end) || start < 1 || end > chapters.length || start > end) { alert('无效的章节序号。'); return; } let texts = []; for (let i = start; i <= end; i++) { texts.push(getTextForChapter(i)); } text = texts.join('\n\n'); rangeDesc = `第 ${start}${start === end ? '' : '-' + end} 章`; } if(text) getSequel(text, rangeDesc); });

        pageInfo.addEventListener('click', () => { if (!totalPages || totalPages <= 0) return; const targetPageStr = prompt(`请输入要跳转的页码 (1 - ${totalPages}):`, currentPage); if (!targetPageStr) return; const targetPage = parseInt(targetPageStr, 10); if (!isNaN(targetPage) && targetPage >= 1 && targetPage <= totalPages) jumpToPage(targetPage); else alert(`输入无效。`); });
        contentWrapper.addEventListener('click', (event) => { 
            if (ignoreNextClick) { ignoreNextClick = false; return; } 
            if (isTransitioning || window.getSelection().toString().length > 0) return;
            
            const rect = event.currentTarget.getBoundingClientRect();
            const clickX = event.clientX;
            const leftBoundary = rect.left + rect.width / 3;
            const rightBoundary = rect.right - rect.width / 3;
            
            if (settings.enableClickPage && clickX < leftBoundary) {
                jumpToPage(currentPage - 1);
            } else if (settings.enableClickPage && clickX > rightBoundary) {
                jumpToPage(currentPage + 1);
            } else { // Middle click
                if (isInImmersiveMode) {
                    toggleImmersiveMode();
                }
            }
        });
        contentWrapper.addEventListener('mousedown', dragStart); contentWrapper.addEventListener('touchstart', dragStart, { passive: true });
        document.addEventListener('mousemove', dragMove); document.addEventListener('touchmove', dragMove, { passive: true });
        ['mouseup', 'mouseleave', 'touchend'].forEach(evt => document.addEventListener(evt, dragEnd));

        bookshelfGrid.addEventListener('mousedown', shelfDragStart);
        bookshelfGrid.addEventListener('touchstart', shelfDragStart, { passive: false });
        document.addEventListener('mousemove', shelfDragMove);
        document.addEventListener('touchmove', shelfDragMove, { passive: false });
        ['mouseup', 'mouseleave', 'touchend'].forEach(evt => document.addEventListener(evt, shelfDragEnd));

        setupModal(settingsModal, btnSettings);
        setupModal(fontSettingsModal, btnFontSettings,
            () => { fontSettingsChanged = false; },
            () => { if (fontSettingsChanged) { rePaginateBook(); fontSettingsChanged = false; } }
        );
        setupModal(catalogModal, btnCatalog);
        setupModal(aiSettingsModal, btnAiSettings);
        setupModal(aiMenuModal, btnAiMenu);
        setupModal(summaryChoiceModal);
        setupModal(summaryDisplayModal);
        setupModal(translationChoiceModal);
        setupModal(summaryHistoryModal);
        setupModal(sequelHistoryModal);
        setupModal(translationHistoryModal);
        setupModal(sequelChoiceModal);
        setupModal(tagEditModal, null, null, closeTagModalAndRefresh);

        window.addEventListener('resize', () => { clearTimeout(window.resizeTimer); window.resizeTimer = setTimeout(() => { if (currentFileName && readerView.style.display !== 'none') { clearSearch(); if (isDragging) dragEnd(); rePaginateBook(); } }, 250); });

        // --- App Initialization ---
        async function runMigration() {
            if (bookshelf.length > 0 && bookshelf[0].hasOwnProperty('content')) {
                appLoader.classList.remove('hidden');
                appLoader.querySelector('span').textContent = '正在升级书库格式，请稍候...';

                const migrationPromises = bookshelf.map(book => 
                    storageDB.saveBook({ id: book.name, content: book.content })
                );
                
                await Promise.all(migrationPromises);

                // Create new bookshelf with metadata only
                bookshelf = bookshelf.map(book => ({
                    name: book.name,
                    cover: book.cover,
                    tags: book.tags || []
                }));

                saveBookshelf();
                appLoader.querySelector('span').textContent = '升级完成！';
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
        }

        document.addEventListener('DOMContentLoaded', async () => {
            if (typeof JSZip === 'undefined') {
                document.body.innerHTML = '<h1>关键组件 JSZip 加载失败，请检查网络连接或文件完整性。</h1>';
                return;
            }
            try {
                await storageDB.init();
            } catch (e) {
                console.error("数据库初始化失败:", e);
                document.body.innerHTML = `<h1>数据库初始化失败，阅读器无法工作。请确保浏览器支持 IndexedDB 且未处于隐私模式。</h1><p>${e.message}</p>`;
                return;
            }
            
            loadSettings(); 
            applyInitialTheme();
            
            loadBookshelf();
            await runMigration(); // Run migration if necessary

            await loadAndApplyAssetsFromDB();
            loadAiSettings(); 
            applySettings();
            showBookshelfView(); 
            appLoader.classList.add('hidden');
        });
    </script>
</body>
</html>
